From 9d81fa71539abae7bb7da53ea6824ab1743972d8 Mon Sep 17 00:00:00 2001
From: Zach Brown <Zbob750@live.com>
Date: Tue, 22 Jul 2014 21:05:53 -0500
Subject: [PATCH] mc-dev imports


diff --git a/src/main/java/net/minecraft/server/BiomeBase.java b/src/main/java/net/minecraft/server/BiomeBase.java
new file mode 100644
index 000000000..1372955b3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeBase.java
@@ -0,0 +1,391 @@
+package net.minecraft.server;
+
+import net.minecraft.util.com.google.common.collect.Sets;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+
+public abstract class BiomeBase {
+
+    private static final Logger aC = LogManager.getLogger();
+    protected static final BiomeTemperature a = new BiomeTemperature(0.1F, 0.2F);
+    protected static final BiomeTemperature b = new BiomeTemperature(-0.5F, 0.0F);
+    protected static final BiomeTemperature c = new BiomeTemperature(-1.0F, 0.1F);
+    protected static final BiomeTemperature d = new BiomeTemperature(-1.8F, 0.1F);
+    protected static final BiomeTemperature e = new BiomeTemperature(0.125F, 0.05F);
+    protected static final BiomeTemperature f = new BiomeTemperature(0.2F, 0.2F);
+    protected static final BiomeTemperature g = new BiomeTemperature(0.45F, 0.3F);
+    protected static final BiomeTemperature h = new BiomeTemperature(1.5F, 0.025F);
+    protected static final BiomeTemperature i = new BiomeTemperature(1.0F, 0.5F);
+    protected static final BiomeTemperature j = new BiomeTemperature(0.0F, 0.025F);
+    protected static final BiomeTemperature k = new BiomeTemperature(0.1F, 0.8F);
+    protected static final BiomeTemperature l = new BiomeTemperature(0.2F, 0.3F);
+    protected static final BiomeTemperature m = new BiomeTemperature(-0.2F, 0.1F);
+    private static final BiomeBase[] biomes = new BiomeBase[256];
+    public static final Set n = Sets.newHashSet();
+    public static final BiomeBase OCEAN = (new BiomeOcean(0)).b(112).a("Ocean").a(c);
+    public static final BiomeBase PLAINS = (new BiomePlains(1)).b(9286496).a("Plains");
+    public static final BiomeBase DESERT = (new BiomeDesert(2)).b(16421912).a("Desert").b().a(2.0F, 0.0F).a(e);
+    public static final BiomeBase EXTREME_HILLS = (new BiomeBigHills(3, false)).b(6316128).a("Extreme Hills").a(i).a(0.2F, 0.3F);
+    public static final BiomeBase FOREST = (new BiomeForest(4, 0)).b(353825).a("Forest");
+    public static final BiomeBase TAIGA = (new BiomeTaiga(5, 0)).b(747097).a("Taiga").a(5159473).a(0.25F, 0.8F).a(f);
+    public static final BiomeBase SWAMPLAND = (new BiomeSwamp(6)).b(522674).a("Swampland").a(9154376).a(m).a(0.8F, 0.9F);
+    public static final BiomeBase RIVER = (new BiomeRiver(7)).b(255).a("River").a(b);
+    public static final BiomeBase HELL = (new BiomeHell(8)).b(16711680).a("Hell").b().a(2.0F, 0.0F);
+    public static final BiomeBase SKY = (new BiomeTheEnd(9)).b(8421631).a("Sky").b();
+    public static final BiomeBase FROZEN_OCEAN = (new BiomeOcean(10)).b(9474208).a("FrozenOcean").c().a(c).a(0.0F, 0.5F);
+    public static final BiomeBase FROZEN_RIVER = (new BiomeRiver(11)).b(10526975).a("FrozenRiver").c().a(b).a(0.0F, 0.5F);
+    public static final BiomeBase ICE_PLAINS = (new BiomeIcePlains(12, false)).b(16777215).a("Ice Plains").c().a(0.0F, 0.5F).a(e);
+    public static final BiomeBase ICE_MOUNTAINS = (new BiomeIcePlains(13, false)).b(10526880).a("Ice Mountains").c().a(g).a(0.0F, 0.5F);
+    public static final BiomeBase MUSHROOM_ISLAND = (new BiomeMushrooms(14)).b(16711935).a("MushroomIsland").a(0.9F, 1.0F).a(l);
+    public static final BiomeBase MUSHROOM_SHORE = (new BiomeMushrooms(15)).b(10486015).a("MushroomIslandShore").a(0.9F, 1.0F).a(j);
+    public static final BiomeBase BEACH = (new BiomeBeach(16)).b(16440917).a("Beach").a(0.8F, 0.4F).a(j);
+    public static final BiomeBase DESERT_HILLS = (new BiomeDesert(17)).b(13786898).a("DesertHills").b().a(2.0F, 0.0F).a(g);
+    public static final BiomeBase FOREST_HILLS = (new BiomeForest(18, 0)).b(2250012).a("ForestHills").a(g);
+    public static final BiomeBase TAIGA_HILLS = (new BiomeTaiga(19, 0)).b(1456435).a("TaigaHills").a(5159473).a(0.25F, 0.8F).a(g);
+    public static final BiomeBase SMALL_MOUNTAINS = (new BiomeBigHills(20, true)).b(7501978).a("Extreme Hills Edge").a(i.a()).a(0.2F, 0.3F);
+    public static final BiomeBase JUNGLE = (new BiomeJungle(21, false)).b(5470985).a("Jungle").a(5470985).a(0.95F, 0.9F);
+    public static final BiomeBase JUNGLE_HILLS = (new BiomeJungle(22, false)).b(2900485).a("JungleHills").a(5470985).a(0.95F, 0.9F).a(g);
+    public static final BiomeBase JUNGLE_EDGE = (new BiomeJungle(23, true)).b(6458135).a("JungleEdge").a(5470985).a(0.95F, 0.8F);
+    public static final BiomeBase DEEP_OCEAN = (new BiomeOcean(24)).b(48).a("Deep Ocean").a(d);
+    public static final BiomeBase STONE_BEACH = (new BiomeStoneBeach(25)).b(10658436).a("Stone Beach").a(0.2F, 0.3F).a(k);
+    public static final BiomeBase COLD_BEACH = (new BiomeBeach(26)).b(16445632).a("Cold Beach").a(0.05F, 0.3F).a(j).c();
+    public static final BiomeBase BIRCH_FOREST = (new BiomeForest(27, 2)).a("Birch Forest").b(3175492);
+    public static final BiomeBase BIRCH_FOREST_HILLS = (new BiomeForest(28, 2)).a("Birch Forest Hills").b(2055986).a(g);
+    public static final BiomeBase ROOFED_FOREST = (new BiomeForest(29, 3)).b(4215066).a("Roofed Forest");
+    public static final BiomeBase COLD_TAIGA = (new BiomeTaiga(30, 0)).b(3233098).a("Cold Taiga").a(5159473).c().a(-0.5F, 0.4F).a(f).c(16777215);
+    public static final BiomeBase COLD_TAIGA_HILLS = (new BiomeTaiga(31, 0)).b(2375478).a("Cold Taiga Hills").a(5159473).c().a(-0.5F, 0.4F).a(g).c(16777215);
+    public static final BiomeBase MEGA_TAIGA = (new BiomeTaiga(32, 1)).b(5858897).a("Mega Taiga").a(5159473).a(0.3F, 0.8F).a(f);
+    public static final BiomeBase MEGA_TAIGA_HILLS = (new BiomeTaiga(33, 1)).b(4542270).a("Mega Taiga Hills").a(5159473).a(0.3F, 0.8F).a(g);
+    public static final BiomeBase EXTREME_HILLS_PLUS = (new BiomeBigHills(34, true)).b(5271632).a("Extreme Hills+").a(i).a(0.2F, 0.3F);
+    public static final BiomeBase SAVANNA = (new BiomeSavanna(35)).b(12431967).a("Savanna").a(1.2F, 0.0F).b().a(e);
+    public static final BiomeBase SAVANNA_PLATEAU = (new BiomeSavanna(36)).b(10984804).a("Savanna Plateau").a(1.0F, 0.0F).b().a(h);
+    public static final BiomeBase MESA = (new BiomeMesa(37, false, false)).b(14238997).a("Mesa");
+    public static final BiomeBase MESA_PLATEAU_F = (new BiomeMesa(38, false, true)).b(11573093).a("Mesa Plateau F").a(h);
+    public static final BiomeBase MESA_PLATEAU = (new BiomeMesa(39, false, false)).b(13274213).a("Mesa Plateau").a(h);
+    protected static final NoiseGenerator3 ac;
+    protected static final NoiseGenerator3 ad;
+    protected static final WorldGenTallPlant ae;
+    public String af;
+    public int ag;
+    public int ah;
+    public Block ai;
+    public int aj;
+    public Block ak;
+    public int al;
+    public float am;
+    public float an;
+    public float temperature;
+    public float humidity;
+    public int aq;
+    public BiomeDecorator ar;
+    protected List as;
+    protected List at;
+    protected List au;
+    protected List av;
+    protected boolean aw;
+    protected boolean ax;
+    public final int id;
+    protected WorldGenTrees az;
+    protected WorldGenBigTree aA;
+    protected WorldGenSwampTree aB;
+
+    protected BiomeBase(int i) {
+        this.ai = Blocks.GRASS;
+        this.aj = 0;
+        this.ak = Blocks.DIRT;
+        this.al = 5169201;
+        this.am = a.a;
+        this.an = a.b;
+        this.temperature = 0.5F;
+        this.humidity = 0.5F;
+        this.aq = 16777215;
+        this.as = new ArrayList();
+        this.at = new ArrayList();
+        this.au = new ArrayList();
+        this.av = new ArrayList();
+        this.ax = true;
+        this.az = new WorldGenTrees(false);
+        this.aA = new WorldGenBigTree(false);
+        this.aB = new WorldGenSwampTree();
+        this.id = i;
+        biomes[i] = this;
+        this.ar = this.a();
+        this.at.add(new BiomeMeta(EntitySheep.class, 12, 4, 4));
+        this.at.add(new BiomeMeta(EntityPig.class, 10, 4, 4));
+        this.at.add(new BiomeMeta(EntityChicken.class, 10, 4, 4));
+        this.at.add(new BiomeMeta(EntityCow.class, 8, 4, 4));
+        this.as.add(new BiomeMeta(EntitySpider.class, 100, 4, 4));
+        this.as.add(new BiomeMeta(EntityZombie.class, 100, 4, 4));
+        this.as.add(new BiomeMeta(EntitySkeleton.class, 100, 4, 4));
+        this.as.add(new BiomeMeta(EntityCreeper.class, 100, 4, 4));
+        this.as.add(new BiomeMeta(EntitySlime.class, 100, 4, 4));
+        this.as.add(new BiomeMeta(EntityEnderman.class, 10, 1, 4));
+        this.as.add(new BiomeMeta(EntityWitch.class, 5, 1, 1));
+        this.au.add(new BiomeMeta(EntitySquid.class, 10, 4, 4));
+        this.av.add(new BiomeMeta(EntityBat.class, 10, 8, 8));
+    }
+
+    protected BiomeDecorator a() {
+        return new BiomeDecorator();
+    }
+
+    protected BiomeBase a(float f, float f1) {
+        if (f > 0.1F && f < 0.2F) {
+            throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
+        } else {
+            this.temperature = f;
+            this.humidity = f1;
+            return this;
+        }
+    }
+
+    protected final BiomeBase a(BiomeTemperature biometemperature) {
+        this.am = biometemperature.a;
+        this.an = biometemperature.b;
+        return this;
+    }
+
+    protected BiomeBase b() {
+        this.ax = false;
+        return this;
+    }
+
+    public WorldGenTreeAbstract a(Random random) {
+        return (WorldGenTreeAbstract) (random.nextInt(10) == 0 ? this.aA : this.az);
+    }
+
+    public WorldGenerator b(Random random) {
+        return new WorldGenGrass(Blocks.LONG_GRASS, 1);
+    }
+
+    public String a(Random random, int i, int j, int k) {
+        return random.nextInt(3) > 0 ? BlockFlowers.b[0] : BlockFlowers.a[0];
+    }
+
+    protected BiomeBase c() {
+        this.aw = true;
+        return this;
+    }
+
+    protected BiomeBase a(String s) {
+        this.af = s;
+        return this;
+    }
+
+    protected BiomeBase a(int i) {
+        this.al = i;
+        return this;
+    }
+
+    protected BiomeBase b(int i) {
+        this.a(i, false);
+        return this;
+    }
+
+    protected BiomeBase c(int i) {
+        this.ah = i;
+        return this;
+    }
+
+    protected BiomeBase a(int i, boolean flag) {
+        this.ag = i;
+        if (flag) {
+            this.ah = (i & 16711422) >> 1;
+        } else {
+            this.ah = i;
+        }
+
+        return this;
+    }
+
+    public List getMobs(EnumCreatureType enumcreaturetype) {
+        return enumcreaturetype == EnumCreatureType.MONSTER ? this.as : (enumcreaturetype == EnumCreatureType.CREATURE ? this.at : (enumcreaturetype == EnumCreatureType.WATER_CREATURE ? this.au : (enumcreaturetype == EnumCreatureType.AMBIENT ? this.av : null)));
+    }
+
+    public boolean d() {
+        return this.j();
+    }
+
+    public boolean e() {
+        return this.j() ? false : this.ax;
+    }
+
+    public boolean f() {
+        return this.humidity > 0.85F;
+    }
+
+    public float g() {
+        return 0.1F;
+    }
+
+    public final int h() {
+        return (int) (this.humidity * 65536.0F);
+    }
+
+    public final float a(int i, int j, int k) {
+        if (j > 64) {
+            float f = (float) ac.a((double) i * 1.0D / 8.0D, (double) k * 1.0D / 8.0D) * 4.0F;
+
+            return this.temperature - (f + (float) j - 64.0F) * 0.05F / 30.0F;
+        } else {
+            return this.temperature;
+        }
+    }
+
+    public void a(World world, Random random, int i, int j) {
+        this.ar.a(world, random, this, i, j);
+    }
+
+    public boolean j() {
+        return this.aw;
+    }
+
+    public void a(World world, Random random, Block[] ablock, byte[] abyte, int i, int j, double d0) {
+        this.b(world, random, ablock, abyte, i, j, d0);
+    }
+
+    public final void b(World world, Random random, Block[] ablock, byte[] abyte, int i, int j, double d0) {
+        boolean flag = true;
+        Block block = this.ai;
+        byte b0 = (byte) (this.aj & 255);
+        Block block1 = this.ak;
+        int k = -1;
+        int l = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        int i1 = i & 15;
+        int j1 = j & 15;
+        int k1 = ablock.length / 256;
+
+        for (int l1 = 255; l1 >= 0; --l1) {
+            int i2 = (j1 * 16 + i1) * k1 + l1;
+
+            if (l1 <= 0 + random.nextInt(5)) {
+                ablock[i2] = Blocks.BEDROCK;
+            } else {
+                Block block2 = ablock[i2];
+
+                if (block2 != null && block2.getMaterial() != Material.AIR) {
+                    if (block2 == Blocks.STONE) {
+                        if (k == -1) {
+                            if (l <= 0) {
+                                block = null;
+                                b0 = 0;
+                                block1 = Blocks.STONE;
+                            } else if (l1 >= 59 && l1 <= 64) {
+                                block = this.ai;
+                                b0 = (byte) (this.aj & 255);
+                                block1 = this.ak;
+                            }
+
+                            if (l1 < 63 && (block == null || block.getMaterial() == Material.AIR)) {
+                                if (this.a(i, l1, j) < 0.15F) {
+                                    block = Blocks.ICE;
+                                    b0 = 0;
+                                } else {
+                                    block = Blocks.STATIONARY_WATER;
+                                    b0 = 0;
+                                }
+                            }
+
+                            k = l;
+                            if (l1 >= 62) {
+                                ablock[i2] = block;
+                                abyte[i2] = b0;
+                            } else if (l1 < 56 - l) {
+                                block = null;
+                                block1 = Blocks.STONE;
+                                ablock[i2] = Blocks.GRAVEL;
+                            } else {
+                                ablock[i2] = block1;
+                            }
+                        } else if (k > 0) {
+                            --k;
+                            ablock[i2] = block1;
+                            if (k == 0 && block1 == Blocks.SAND) {
+                                k = random.nextInt(4) + Math.max(0, l1 - 63);
+                                block1 = Blocks.SANDSTONE;
+                            }
+                        }
+                    }
+                } else {
+                    k = -1;
+                }
+            }
+        }
+    }
+
+    protected BiomeBase k() {
+        return new BiomeBaseSub(this.id + 128, this);
+    }
+
+    public Class l() {
+        return this.getClass();
+    }
+
+    public boolean a(BiomeBase biomebase) {
+        return biomebase == this ? true : (biomebase == null ? false : this.l() == biomebase.l());
+    }
+
+    public EnumTemperature m() {
+        return (double) this.temperature < 0.2D ? EnumTemperature.COLD : ((double) this.temperature < 1.0D ? EnumTemperature.MEDIUM : EnumTemperature.WARM);
+    }
+
+    public static BiomeBase[] getBiomes() {
+        return biomes;
+    }
+
+    public static BiomeBase getBiome(int i) {
+        if (i >= 0 && i <= biomes.length) {
+            return biomes[i];
+        } else {
+            aC.warn("Biome ID is out of bounds: " + i + ", defaulting to 0 (Ocean)");
+            return OCEAN;
+        }
+    }
+
+    static {
+        PLAINS.k();
+        DESERT.k();
+        FOREST.k();
+        TAIGA.k();
+        SWAMPLAND.k();
+        ICE_PLAINS.k();
+        JUNGLE.k();
+        JUNGLE_EDGE.k();
+        COLD_TAIGA.k();
+        SAVANNA.k();
+        SAVANNA_PLATEAU.k();
+        MESA.k();
+        MESA_PLATEAU_F.k();
+        MESA_PLATEAU.k();
+        BIRCH_FOREST.k();
+        BIRCH_FOREST_HILLS.k();
+        ROOFED_FOREST.k();
+        MEGA_TAIGA.k();
+        EXTREME_HILLS.k();
+        EXTREME_HILLS_PLUS.k();
+        biomes[MEGA_TAIGA_HILLS.id + 128] = biomes[MEGA_TAIGA.id + 128];
+        BiomeBase[] abiomebase = biomes;
+        int i = abiomebase.length;
+
+        for (int j = 0; j < i; ++j) {
+            BiomeBase biomebase = abiomebase[j];
+
+            if (biomebase != null && biomebase.id < 128) {
+                n.add(biomebase);
+            }
+        }
+
+        n.remove(HELL);
+        n.remove(SKY);
+        n.remove(FROZEN_OCEAN);
+        n.remove(SMALL_MOUNTAINS);
+        ac = new NoiseGenerator3(new Random(1234L), 1);
+        ad = new NoiseGenerator3(new Random(2345L), 1);
+        ae = new WorldGenTallPlant();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BiomeCache.java b/src/main/java/net/minecraft/server/BiomeCache.java
new file mode 100644
index 000000000..833854f5f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeCache.java
@@ -0,0 +1,65 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class BiomeCache {
+
+    private final WorldChunkManager a;
+    private long b;
+    private LongHashMap c = new LongHashMap();
+    private List d = new ArrayList();
+
+    public BiomeCache(WorldChunkManager worldchunkmanager) {
+        this.a = worldchunkmanager;
+    }
+
+    public BiomeCacheBlock a(int i, int j) {
+        i >>= 4;
+        j >>= 4;
+        long k = (long) i & 4294967295L | ((long) j & 4294967295L) << 32;
+        BiomeCacheBlock biomecacheblock = (BiomeCacheBlock) this.c.getEntry(k);
+
+        if (biomecacheblock == null) {
+            biomecacheblock = new BiomeCacheBlock(this, i, j);
+            this.c.put(k, biomecacheblock);
+            this.d.add(biomecacheblock);
+        }
+
+        biomecacheblock.e = MinecraftServer.ar();
+        return biomecacheblock;
+    }
+
+    public BiomeBase b(int i, int j) {
+        return this.a(i, j).a(i, j);
+    }
+
+    public void a() {
+        long i = MinecraftServer.ar();
+        long j = i - this.b;
+
+        if (j > 7500L || j < 0L) {
+            this.b = i;
+
+            for (int k = 0; k < this.d.size(); ++k) {
+                BiomeCacheBlock biomecacheblock = (BiomeCacheBlock) this.d.get(k);
+                long l = i - biomecacheblock.e;
+
+                if (l > 30000L || l < 0L) {
+                    this.d.remove(k--);
+                    long i1 = (long) biomecacheblock.c & 4294967295L | ((long) biomecacheblock.d & 4294967295L) << 32;
+
+                    this.c.remove(i1);
+                }
+            }
+        }
+    }
+
+    public BiomeBase[] d(int i, int j) {
+        return this.a(i, j).b;
+    }
+
+    static WorldChunkManager a(BiomeCache biomecache) {
+        return biomecache.a;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/BiomeMesa.java b/src/main/java/net/minecraft/server/BiomeMesa.java
new file mode 100644
index 000000000..7a184e23a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeMesa.java
@@ -0,0 +1,279 @@
+package net.minecraft.server;
+
+import java.util.Arrays;
+import java.util.Random;
+
+public class BiomeMesa extends BiomeBase {
+
+    private byte[] aC;
+    private long aD;
+    private NoiseGenerator3 aE;
+    private NoiseGenerator3 aF;
+    private NoiseGenerator3 aG;
+    private boolean aH;
+    private boolean aI;
+
+    public BiomeMesa(int i, boolean flag, boolean flag1) {
+        super(i);
+        this.aH = flag;
+        this.aI = flag1;
+        this.b();
+        this.a(2.0F, 0.0F);
+        this.at.clear();
+        this.ai = Blocks.SAND;
+        this.aj = 1;
+        this.ak = Blocks.STAINED_HARDENED_CLAY;
+        this.ar.x = -999;
+        this.ar.A = 20;
+        this.ar.C = 3;
+        this.ar.D = 5;
+        this.ar.y = 0;
+        this.at.clear();
+        if (flag1) {
+            this.ar.x = 5;
+        }
+    }
+
+    public WorldGenTreeAbstract a(Random random) {
+        return this.az;
+    }
+
+    public void a(World world, Random random, int i, int j) {
+        super.a(world, random, i, j);
+    }
+
+    public void a(World world, Random random, Block[] ablock, byte[] abyte, int i, int j, double d0) {
+        if (this.aC == null || this.aD != world.getSeed()) {
+            this.a(world.getSeed());
+        }
+
+        if (this.aE == null || this.aF == null || this.aD != world.getSeed()) {
+            Random random1 = new Random(this.aD);
+
+            this.aE = new NoiseGenerator3(random1, 4);
+            this.aF = new NoiseGenerator3(random1, 1);
+        }
+
+        this.aD = world.getSeed();
+        double d1 = 0.0D;
+        int k;
+        int l;
+
+        if (this.aH) {
+            k = (i & -16) + (j & 15);
+            l = (j & -16) + (i & 15);
+            double d2 = Math.min(Math.abs(d0), this.aE.a((double) k * 0.25D, (double) l * 0.25D));
+
+            if (d2 > 0.0D) {
+                double d3 = 0.001953125D;
+                double d4 = Math.abs(this.aF.a((double) k * d3, (double) l * d3));
+
+                d1 = d2 * d2 * 2.5D;
+                double d5 = Math.ceil(d4 * 50.0D) + 14.0D;
+
+                if (d1 > d5) {
+                    d1 = d5;
+                }
+
+                d1 += 64.0D;
+            }
+        }
+
+        k = i & 15;
+        l = j & 15;
+        boolean flag = true;
+        Block block = Blocks.STAINED_HARDENED_CLAY;
+        Block block1 = this.ak;
+        int i1 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        boolean flag1 = Math.cos(d0 / 3.0D * 3.141592653589793D) > 0.0D;
+        int j1 = -1;
+        boolean flag2 = false;
+        int k1 = ablock.length / 256;
+
+        for (int l1 = 255; l1 >= 0; --l1) {
+            int i2 = (l * 16 + k) * k1 + l1;
+
+            if ((ablock[i2] == null || ablock[i2].getMaterial() == Material.AIR) && l1 < (int) d1) {
+                ablock[i2] = Blocks.STONE;
+            }
+
+            if (l1 <= 0 + random.nextInt(5)) {
+                ablock[i2] = Blocks.BEDROCK;
+            } else {
+                Block block2 = ablock[i2];
+
+                if (block2 != null && block2.getMaterial() != Material.AIR) {
+                    if (block2 == Blocks.STONE) {
+                        byte b0;
+
+                        if (j1 == -1) {
+                            flag2 = false;
+                            if (i1 <= 0) {
+                                block = null;
+                                block1 = Blocks.STONE;
+                            } else if (l1 >= 59 && l1 <= 64) {
+                                block = Blocks.STAINED_HARDENED_CLAY;
+                                block1 = this.ak;
+                            }
+
+                            if (l1 < 63 && (block == null || block.getMaterial() == Material.AIR)) {
+                                block = Blocks.STATIONARY_WATER;
+                            }
+
+                            j1 = i1 + Math.max(0, l1 - 63);
+                            if (l1 >= 62) {
+                                if (this.aI && l1 > 86 + i1 * 2) {
+                                    if (flag1) {
+                                        ablock[i2] = Blocks.DIRT;
+                                        abyte[i2] = 1;
+                                    } else {
+                                        ablock[i2] = Blocks.GRASS;
+                                    }
+                                } else if (l1 > 66 + i1) {
+                                    b0 = 16;
+                                    if (l1 >= 64 && l1 <= 127) {
+                                        if (!flag1) {
+                                            b0 = this.d(i, l1, j);
+                                        }
+                                    } else {
+                                        b0 = 1;
+                                    }
+
+                                    if (b0 < 16) {
+                                        ablock[i2] = Blocks.STAINED_HARDENED_CLAY;
+                                        abyte[i2] = (byte) b0;
+                                    } else {
+                                        ablock[i2] = Blocks.HARDENED_CLAY;
+                                    }
+                                } else {
+                                    ablock[i2] = this.ai;
+                                    abyte[i2] = (byte) this.aj;
+                                    flag2 = true;
+                                }
+                            } else {
+                                ablock[i2] = block1;
+                                if (block1 == Blocks.STAINED_HARDENED_CLAY) {
+                                    abyte[i2] = 1;
+                                }
+                            }
+                        } else if (j1 > 0) {
+                            --j1;
+                            if (flag2) {
+                                ablock[i2] = Blocks.STAINED_HARDENED_CLAY;
+                                abyte[i2] = 1;
+                            } else {
+                                b0 = this.d(i, l1, j);
+                                if (b0 < 16) {
+                                    ablock[i2] = Blocks.STAINED_HARDENED_CLAY;
+                                    abyte[i2] = b0;
+                                } else {
+                                    ablock[i2] = Blocks.HARDENED_CLAY;
+                                }
+                            }
+                        }
+                    }
+                } else {
+                    j1 = -1;
+                }
+            }
+        }
+    }
+
+    private void a(long i) {
+        this.aC = new byte[64];
+        Arrays.fill(this.aC, (byte) 16);
+        Random random = new Random(i);
+
+        this.aG = new NoiseGenerator3(random, 1);
+
+        int j;
+
+        for (j = 0; j < 64; ++j) {
+            j += random.nextInt(5) + 1;
+            if (j < 64) {
+                this.aC[j] = 1;
+            }
+        }
+
+        j = random.nextInt(4) + 2;
+
+        int k;
+        int l;
+        int i1;
+        int j1;
+
+        for (k = 0; k < j; ++k) {
+            l = random.nextInt(3) + 1;
+            i1 = random.nextInt(64);
+
+            for (j1 = 0; i1 + j1 < 64 && j1 < l; ++j1) {
+                this.aC[i1 + j1] = 4;
+            }
+        }
+
+        k = random.nextInt(4) + 2;
+
+        int k1;
+
+        for (l = 0; l < k; ++l) {
+            i1 = random.nextInt(3) + 2;
+            j1 = random.nextInt(64);
+
+            for (k1 = 0; j1 + k1 < 64 && k1 < i1; ++k1) {
+                this.aC[j1 + k1] = 12;
+            }
+        }
+
+        l = random.nextInt(4) + 2;
+
+        for (i1 = 0; i1 < l; ++i1) {
+            j1 = random.nextInt(3) + 1;
+            k1 = random.nextInt(64);
+
+            for (int l1 = 0; k1 + l1 < 64 && l1 < j1; ++l1) {
+                this.aC[k1 + l1] = 14;
+            }
+        }
+
+        i1 = random.nextInt(3) + 3;
+        j1 = 0;
+
+        for (k1 = 0; k1 < i1; ++k1) {
+            byte b0 = 1;
+
+            j1 += random.nextInt(16) + 4;
+
+            for (int i2 = 0; j1 + i2 < 64 && i2 < b0; ++i2) {
+                this.aC[j1 + i2] = 0;
+                if (j1 + i2 > 1 && random.nextBoolean()) {
+                    this.aC[j1 + i2 - 1] = 8;
+                }
+
+                if (j1 + i2 < 63 && random.nextBoolean()) {
+                    this.aC[j1 + i2 + 1] = 8;
+                }
+            }
+        }
+    }
+
+    private byte d(int i, int j, int k) {
+        int l = (int) Math.round(this.aG.a((double) i * 1.0D / 512.0D, (double) i * 1.0D / 512.0D) * 2.0D);
+
+        return this.aC[(j + l + 64) % 64];
+    }
+
+    protected BiomeBase k() {
+        boolean flag = this.id == BiomeBase.MESA.id;
+        BiomeMesa biomemesa = new BiomeMesa(this.id + 128, flag, this.aI);
+
+        if (!flag) {
+            biomemesa.a(g);
+            biomemesa.a(this.af + " M");
+        } else {
+            biomemesa.a(this.af + " (Bryce)");
+        }
+
+        biomemesa.a(this.ag, true);
+        return biomemesa;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFalling.java b/src/main/java/net/minecraft/server/BlockFalling.java
new file mode 100644
index 000000000..473fc3121
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFalling.java
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFalling extends Block {
+
+    public static boolean instaFall;
+
+    public BlockFalling() {
+        super(Material.SAND);
+        this.a(CreativeModeTab.b);
+    }
+
+    public BlockFalling(Material material) {
+        super(material);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        world.a(i, j, k, this, this.a(world));
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        world.a(i, j, k, this, this.a(world));
+    }
+
+    public void a(World world, int i, int j, int k, Random random) {
+        if (!world.isStatic) {
+            this.m(world, i, j, k);
+        }
+    }
+
+    private void m(World world, int i, int j, int k) {
+        if (canFall(world, i, j - 1, k) && j >= 0) {
+            byte b0 = 32;
+
+            if (!instaFall && world.b(i - b0, j - b0, k - b0, i + b0, j + b0, k + b0)) {
+                if (!world.isStatic) {
+                    EntityFallingBlock entityfallingblock = new EntityFallingBlock(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), this, world.getData(i, j, k));
+
+                    this.a(entityfallingblock);
+                    world.addEntity(entityfallingblock);
+                }
+            } else {
+                world.setAir(i, j, k);
+
+                while (canFall(world, i, j - 1, k) && j > 0) {
+                    --j;
+                }
+
+                if (j > 0) {
+                    world.setTypeUpdate(i, j, k, this);
+                }
+            }
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {}
+
+    public int a(World world) {
+        return 2;
+    }
+
+    public static boolean canFall(World world, int i, int j, int k) {
+        Block block = world.getType(i, j, k);
+
+        if (block.material == Material.AIR) {
+            return true;
+        } else if (block == Blocks.FIRE) {
+            return true;
+        } else {
+            Material material = block.material;
+
+            return material == Material.WATER ? true : material == Material.LAVA;
+        }
+    }
+
+    public void a(World world, int i, int j, int k, int l) {}
+}
diff --git a/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
new file mode 100644
index 000000000..d36aacbda
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
@@ -0,0 +1,145 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public abstract class BlockMinecartTrackAbstract extends Block {
+
+    protected final boolean a;
+
+    public static final boolean b_(World world, int i, int j, int k) {
+        return a(world.getType(i, j, k));
+    }
+
+    public static final boolean a(Block block) {
+        return block == Blocks.RAILS || block == Blocks.GOLDEN_RAIL || block == Blocks.DETECTOR_RAIL || block == Blocks.ACTIVATOR_RAIL;
+    }
+
+    protected BlockMinecartTrackAbstract(boolean flag) {
+        super(Material.ORIENTABLE);
+        this.a = flag;
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        this.a(CreativeModeTab.e);
+    }
+
+    public boolean e() {
+        return this.a;
+    }
+
+    public AxisAlignedBB a(World world, int i, int j, int k) {
+        return null;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public MovingObjectPosition a(World world, int i, int j, int k, Vec3D vec3d, Vec3D vec3d1) {
+        this.updateShape(world, i, j, k);
+        return super.a(world, i, j, k, vec3d, vec3d1);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, int i, int j, int k) {
+        int l = iblockaccess.getData(i, j, k);
+
+        if (l >= 2 && l <= 5) {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.625F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        }
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public int b() {
+        return 9;
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return World.a((IBlockAccess) world, i, j - 1, k);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        if (!world.isStatic) {
+            this.a(world, i, j, k, true);
+            if (this.a) {
+                this.doPhysics(world, i, j, k, this);
+            }
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (!world.isStatic) {
+            int l = world.getData(i, j, k);
+            int i1 = l;
+
+            if (this.a) {
+                i1 = l & 7;
+            }
+
+            boolean flag = false;
+
+            if (!World.a((IBlockAccess) world, i, j - 1, k)) {
+                flag = true;
+            }
+
+            if (i1 == 2 && !World.a((IBlockAccess) world, i + 1, j, k)) {
+                flag = true;
+            }
+
+            if (i1 == 3 && !World.a((IBlockAccess) world, i - 1, j, k)) {
+                flag = true;
+            }
+
+            if (i1 == 4 && !World.a((IBlockAccess) world, i, j, k - 1)) {
+                flag = true;
+            }
+
+            if (i1 == 5 && !World.a((IBlockAccess) world, i, j, k + 1)) {
+                flag = true;
+            }
+
+            if (flag) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+            } else {
+                this.a(world, i, j, k, l, i1, block);
+            }
+        }
+    }
+
+    protected void a(World world, int i, int j, int k, int l, int i1, Block block) {}
+
+    protected void a(World world, int i, int j, int k, boolean flag) {
+        if (!world.isStatic) {
+            (new MinecartTrackLogic(this, world, i, j, k)).a(world.isBlockIndirectlyPowered(i, j, k), flag);
+        }
+    }
+
+    public int h() {
+        return 0;
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        int i1 = l;
+
+        if (this.a) {
+            i1 = l & 7;
+        }
+
+        super.remove(world, i, j, k, block, l);
+        if (i1 == 2 || i1 == 3 || i1 == 4 || i1 == 5) {
+            world.applyPhysics(i, j + 1, k, block);
+        }
+
+        if (this.a) {
+            world.applyPhysics(i, j, k, block);
+            world.applyPhysics(i, j - 1, k, block);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTorch.java b/src/main/java/net/minecraft/server/BlockTorch.java
new file mode 100644
index 000000000..d95aff288
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTorch.java
@@ -0,0 +1,167 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTorch extends Block {
+
+    protected BlockTorch() {
+        super(Material.ORIENTABLE);
+        this.a(true);
+        this.a(CreativeModeTab.c);
+    }
+
+    public AxisAlignedBB a(World world, int i, int j, int k) {
+        return null;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public int b() {
+        return 2;
+    }
+
+    private boolean m(World world, int i, int j, int k) {
+        if (World.a((IBlockAccess) world, i, j, k)) {
+            return true;
+        } else {
+            Block block = world.getType(i, j, k);
+
+            return block == Blocks.FENCE || block == Blocks.NETHER_FENCE || block == Blocks.GLASS || block == Blocks.COBBLE_WALL;
+        }
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return world.c(i - 1, j, k, true) ? true : (world.c(i + 1, j, k, true) ? true : (world.c(i, j, k - 1, true) ? true : (world.c(i, j, k + 1, true) ? true : this.m(world, i, j - 1, k))));
+    }
+
+    public int getPlacedData(World world, int i, int j, int k, int l, float f, float f1, float f2, int i1) {
+        int j1 = i1;
+
+        if (l == 1 && this.m(world, i, j - 1, k)) {
+            j1 = 5;
+        }
+
+        if (l == 2 && world.c(i, j, k + 1, true)) {
+            j1 = 4;
+        }
+
+        if (l == 3 && world.c(i, j, k - 1, true)) {
+            j1 = 3;
+        }
+
+        if (l == 4 && world.c(i + 1, j, k, true)) {
+            j1 = 2;
+        }
+
+        if (l == 5 && world.c(i - 1, j, k, true)) {
+            j1 = 1;
+        }
+
+        return j1;
+    }
+
+    public void a(World world, int i, int j, int k, Random random) {
+        super.a(world, i, j, k, random);
+        if (world.getData(i, j, k) == 0) {
+            this.onPlace(world, i, j, k);
+        }
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        if (world.getData(i, j, k) == 0) {
+            if (world.c(i - 1, j, k, true)) {
+                world.setData(i, j, k, 1, 2);
+            } else if (world.c(i + 1, j, k, true)) {
+                world.setData(i, j, k, 2, 2);
+            } else if (world.c(i, j, k - 1, true)) {
+                world.setData(i, j, k, 3, 2);
+            } else if (world.c(i, j, k + 1, true)) {
+                world.setData(i, j, k, 4, 2);
+            } else if (this.m(world, i, j - 1, k)) {
+                world.setData(i, j, k, 5, 2);
+            }
+        }
+
+        this.e(world, i, j, k);
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        this.b(world, i, j, k, block);
+    }
+
+    protected boolean b(World world, int i, int j, int k, Block block) {
+        if (this.e(world, i, j, k)) {
+            int l = world.getData(i, j, k);
+            boolean flag = false;
+
+            if (!world.c(i - 1, j, k, true) && l == 1) {
+                flag = true;
+            }
+
+            if (!world.c(i + 1, j, k, true) && l == 2) {
+                flag = true;
+            }
+
+            if (!world.c(i, j, k - 1, true) && l == 3) {
+                flag = true;
+            }
+
+            if (!world.c(i, j, k + 1, true) && l == 4) {
+                flag = true;
+            }
+
+            if (!this.m(world, i, j - 1, k) && l == 5) {
+                flag = true;
+            }
+
+            if (flag) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            return true;
+        }
+    }
+
+    protected boolean e(World world, int i, int j, int k) {
+        if (!this.canPlace(world, i, j, k)) {
+            if (world.getType(i, j, k) == this) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+            }
+
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    public MovingObjectPosition a(World world, int i, int j, int k, Vec3D vec3d, Vec3D vec3d1) {
+        int l = world.getData(i, j, k) & 7;
+        float f = 0.15F;
+
+        if (l == 1) {
+            this.a(0.0F, 0.2F, 0.5F - f, f * 2.0F, 0.8F, 0.5F + f);
+        } else if (l == 2) {
+            this.a(1.0F - f * 2.0F, 0.2F, 0.5F - f, 1.0F, 0.8F, 0.5F + f);
+        } else if (l == 3) {
+            this.a(0.5F - f, 0.2F, 0.0F, 0.5F + f, 0.8F, f * 2.0F);
+        } else if (l == 4) {
+            this.a(0.5F - f, 0.2F, 1.0F - f * 2.0F, 0.5F + f, 0.8F, 1.0F);
+        } else {
+            f = 0.1F;
+            this.a(0.5F - f, 0.0F, 0.5F - f, 0.5F + f, 0.6F, 0.5F + f);
+        }
+
+        return super.a(world, i, j, k, vec3d, vec3d1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkCoordIntPair.java b/src/main/java/net/minecraft/server/ChunkCoordIntPair.java
new file mode 100644
index 000000000..1594f40de
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCoordIntPair.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+public class ChunkCoordIntPair {
+
+    public final int x;
+    public final int z;
+
+    public ChunkCoordIntPair(int i, int j) {
+        this.x = i;
+        this.z = j;
+    }
+
+    public static long a(int i, int j) {
+        return (long) i & 4294967295L | ((long) j & 4294967295L) << 32;
+    }
+
+    public int hashCode() {
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return i ^ j;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChunkCoordIntPair)) {
+            return false;
+        } else {
+            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) object;
+
+            return this.x == chunkcoordintpair.x && this.z == chunkcoordintpair.z;
+        }
+    }
+
+    public int a() {
+        return (this.x << 4) + 8;
+    }
+
+    public int b() {
+        return (this.z << 4) + 8;
+    }
+
+    public ChunkPosition a(int i) {
+        return new ChunkPosition(this.a(), i, this.b());
+    }
+
+    public String toString() {
+        return "[" + this.x + ", " + this.z + "]";
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
new file mode 100644
index 000000000..374983a06
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -0,0 +1,10 @@
+package net.minecraft.server;
+
+public class ChunkMap {
+
+    public byte[] a;
+    public int b;
+    public int c;
+
+    public ChunkMap() {}
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderFlat.java b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
new file mode 100644
index 000000000..0f7518287
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
@@ -0,0 +1,238 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class ChunkProviderFlat implements IChunkProvider {
+
+    private World a;
+    private Random b;
+    private final Block[] c = new Block[256];
+    private final byte[] d = new byte[256];
+    private final WorldGenFlatInfo e;
+    private final List f = new ArrayList();
+    private final boolean g;
+    private final boolean h;
+    private WorldGenLakes i;
+    private WorldGenLakes j;
+
+    public ChunkProviderFlat(World world, long i, boolean flag, String s) {
+        this.a = world;
+        this.b = new Random(i);
+        this.e = WorldGenFlatInfo.a(s);
+        if (flag) {
+            Map map = this.e.b();
+
+            if (map.containsKey("village")) {
+                Map map1 = (Map) map.get("village");
+
+                if (!map1.containsKey("size")) {
+                    map1.put("size", "1");
+                }
+
+                this.f.add(new WorldGenVillage(map1));
+            }
+
+            if (map.containsKey("biome_1")) {
+                this.f.add(new WorldGenLargeFeature((Map) map.get("biome_1")));
+            }
+
+            if (map.containsKey("mineshaft")) {
+                this.f.add(new WorldGenMineshaft((Map) map.get("mineshaft")));
+            }
+
+            if (map.containsKey("stronghold")) {
+                this.f.add(new WorldGenStronghold((Map) map.get("stronghold")));
+            }
+        }
+
+        this.g = this.e.b().containsKey("decoration");
+        if (this.e.b().containsKey("lake")) {
+            this.i = new WorldGenLakes(Blocks.STATIONARY_WATER);
+        }
+
+        if (this.e.b().containsKey("lava_lake")) {
+            this.j = new WorldGenLakes(Blocks.STATIONARY_LAVA);
+        }
+
+        this.h = this.e.b().containsKey("dungeon");
+        Iterator iterator = this.e.c().iterator();
+
+        while (iterator.hasNext()) {
+            WorldGenFlatLayerInfo worldgenflatlayerinfo = (WorldGenFlatLayerInfo) iterator.next();
+
+            for (int j = worldgenflatlayerinfo.d(); j < worldgenflatlayerinfo.d() + worldgenflatlayerinfo.a(); ++j) {
+                this.c[j] = worldgenflatlayerinfo.b();
+                this.d[j] = (byte) worldgenflatlayerinfo.c();
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        Chunk chunk = new Chunk(this.a, i, j);
+
+        int k;
+
+        for (int l = 0; l < this.c.length; ++l) {
+            Block block = this.c[l];
+
+            if (block != null) {
+                k = l >> 4;
+                ChunkSection chunksection = chunk.getSections()[k];
+
+                if (chunksection == null) {
+                    chunksection = new ChunkSection(l, !this.a.worldProvider.g);
+                    chunk.getSections()[k] = chunksection;
+                }
+
+                for (int i1 = 0; i1 < 16; ++i1) {
+                    for (int j1 = 0; j1 < 16; ++j1) {
+                        chunksection.setTypeId(i1, l & 15, j1, block);
+                        chunksection.setData(i1, l & 15, j1, this.d[l]);
+                    }
+                }
+            }
+        }
+
+        chunk.initLighting();
+        BiomeBase[] abiomebase = this.a.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.m();
+
+        for (k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) abiomebase[k].id;
+        }
+
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            WorldGenBase worldgenbase = (WorldGenBase) iterator.next();
+
+            worldgenbase.a(this, this.a, i, j, (Block[]) null);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        int k = i * 16;
+        int l = j * 16;
+        BiomeBase biomebase = this.a.getBiome(k + 16, l + 16);
+        boolean flag = false;
+
+        this.b.setSeed(this.a.getSeed());
+        long i1 = this.b.nextLong() / 2L * 2L + 1L;
+        long j1 = this.b.nextLong() / 2L * 2L + 1L;
+
+        this.b.setSeed((long) i * i1 + (long) j * j1 ^ this.a.getSeed());
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+            boolean flag1 = structuregenerator.a(this.a, this.b, i, j);
+
+            if (structuregenerator instanceof WorldGenVillage) {
+                flag |= flag1;
+            }
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (this.i != null && !flag && this.b.nextInt(4) == 0) {
+            l1 = k + this.b.nextInt(16) + 8;
+            k1 = this.b.nextInt(256);
+            i2 = l + this.b.nextInt(16) + 8;
+            this.i.generate(this.a, this.b, l1, k1, i2);
+        }
+
+        if (this.j != null && !flag && this.b.nextInt(8) == 0) {
+            l1 = k + this.b.nextInt(16) + 8;
+            k1 = this.b.nextInt(this.b.nextInt(248) + 8);
+            i2 = l + this.b.nextInt(16) + 8;
+            if (k1 < 63 || this.b.nextInt(10) == 0) {
+                this.j.generate(this.a, this.b, l1, k1, i2);
+            }
+        }
+
+        if (this.h) {
+            for (l1 = 0; l1 < 8; ++l1) {
+                k1 = k + this.b.nextInt(16) + 8;
+                i2 = this.b.nextInt(256);
+                int j2 = l + this.b.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.a, this.b, k1, i2, j2);
+            }
+        }
+
+        if (this.g) {
+            biomebase.a(this.a, this.b, k, l);
+        }
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "FlatLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        BiomeBase biomebase = this.a.getBiome(i, k);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        if ("Stronghold".equals(s)) {
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+
+                if (structuregenerator instanceof WorldGenStronghold) {
+                    return structuregenerator.getNearestGeneratedFeature(world, i, j, k);
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+
+            structuregenerator.a(this, this.a, i, j, (Block[]) null);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
new file mode 100644
index 000000000..813df4d63
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
@@ -0,0 +1,392 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGeneratorOctaves l;
+    private NoiseGenerator3 m;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World n;
+    private final boolean o;
+    private WorldType p;
+    private final double[] q;
+    private final float[] r;
+    private double[] s = new double[256];
+    private WorldGenBase t = new WorldGenCaves();
+    private WorldGenStronghold u = new WorldGenStronghold();
+    private WorldGenVillage v = new WorldGenVillage();
+    private WorldGenMineshaft w = new WorldGenMineshaft();
+    private WorldGenLargeFeature x = new WorldGenLargeFeature();
+    private WorldGenBase y = new WorldGenCanyon();
+    private BiomeBase[] z;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+    int[][] h = new int[32][32];
+
+    public ChunkProviderGenerate(World world, long i, boolean flag) {
+        this.n = world;
+        this.o = flag;
+        this.p = world.getWorldData().getType();
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGenerator3(this.i, 4);
+        this.a = new NoiseGeneratorOctaves(this.i, 10);
+        this.b = new NoiseGeneratorOctaves(this.i, 16);
+        this.c = new NoiseGeneratorOctaves(this.i, 8);
+        this.q = new double[825];
+        this.r = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.r[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+    }
+
+    public void a(int i, int j, Block[] ablock) {
+        byte b0 = 63;
+
+        this.z = this.n.getWorldChunkManager().getBiomes(this.z, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.q[k1 + k2];
+                    double d2 = this.q[l1 + k2];
+                    double d3 = this.q[i2 + k2];
+                    double d4 = this.q[j2 + k2];
+                    double d5 = (this.q[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.q[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.q[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.q[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            int j3 = i3 + k * 4 << 12 | 0 + j1 * 4 << 8 | k2 * 8 + l2;
+                            short short1 = 256;
+
+                            j3 -= short1;
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int k3 = 0; k3 < 4; ++k3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    ablock[j3 += short1] = Blocks.STONE;
+                                } else if (k2 * 8 + l2 < b0) {
+                                    ablock[j3 += short1] = Blocks.STATIONARY_WATER;
+                                } else {
+                                    ablock[j3 += short1] = null;
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+    }
+
+    public void a(int i, int j, Block[] ablock, byte[] abyte, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.s = this.m.a(this.s, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.n, this.i, ablock, abyte, i * 16 + k, j * 16 + l, this.s[l + k * 16]);
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        Block[] ablock = new Block[65536];
+        byte[] abyte = new byte[65536];
+
+        this.a(i, j, ablock);
+        this.z = this.n.getWorldChunkManager().getBiomeBlock(this.z, i * 16, j * 16, 16, 16);
+        this.a(i, j, ablock, abyte, this.z);
+        this.t.a(this, this.n, i, j, ablock);
+        this.y.a(this, this.n, i, j, ablock);
+        if (this.o) {
+            this.w.a(this, this.n, i, j, ablock);
+            this.v.a(this, this.n, i, j, ablock);
+            this.u.a(this, this.n, i, j, ablock);
+            this.x.a(this, this.n, i, j, ablock);
+        }
+
+        Chunk chunk = new Chunk(this.n, ablock, abyte, i, j);
+        byte[] abyte1 = chunk.m();
+
+        for (int k = 0; k < abyte1.length; ++k) {
+            abyte1[k] = (byte) this.z[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        double d0 = 684.412D;
+        double d1 = 684.412D;
+        double d2 = 512.0D;
+        double d3 = 512.0D;
+
+        this.g = this.b.a(this.g, i, k, 5, 5, 200.0D, 200.0D, 0.5D);
+        this.d = this.l.a(this.d, i, j, k, 5, 33, 5, 8.555150000000001D, 4.277575000000001D, 8.555150000000001D);
+        this.e = this.j.a(this.e, i, j, k, 5, 33, 5, 684.412D, 684.412D, 684.412D);
+        this.f = this.k.a(this.f, i, j, k, 5, 33, 5, 684.412D, 684.412D, 684.412D);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+        double d4 = 8.5D;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f = 0.0F;
+                float f1 = 0.0F;
+                float f2 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.z[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.z[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f3 = biomebase1.am;
+                        float f4 = biomebase1.an;
+
+                        if (this.p == WorldType.AMPLIFIED && f3 > 0.0F) {
+                            f3 = 1.0F + f3 * 2.0F;
+                            f4 = 1.0F + f4 * 4.0F;
+                        }
+
+                        float f5 = this.r[l1 + 2 + (i2 + 2) * 5] / (f3 + 2.0F);
+
+                        if (biomebase1.am > biomebase.am) {
+                            f5 /= 2.0F;
+                        }
+
+                        f += f4 * f5;
+                        f1 += f3 * f5;
+                        f2 += f5;
+                    }
+                }
+
+                f /= f2;
+                f1 /= f2;
+                f = f * 0.9F + 0.1F;
+                f1 = (f1 * 4.0F - 1.0F) / 8.0F;
+                double d5 = this.g[i1] / 8000.0D;
+
+                if (d5 < 0.0D) {
+                    d5 = -d5 * 0.3D;
+                }
+
+                d5 = d5 * 3.0D - 2.0D;
+                if (d5 < 0.0D) {
+                    d5 /= 2.0D;
+                    if (d5 < -1.0D) {
+                        d5 = -1.0D;
+                    }
+
+                    d5 /= 1.4D;
+                    d5 /= 2.0D;
+                } else {
+                    if (d5 > 1.0D) {
+                        d5 = 1.0D;
+                    }
+
+                    d5 /= 8.0D;
+                }
+
+                ++i1;
+                double d6 = (double) f1;
+                double d7 = (double) f;
+
+                d6 += d5 * 0.2D;
+                d6 = d6 * 8.5D / 8.0D;
+                double d8 = 8.5D + d6 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d9 = ((double) j2 - d8) * 12.0D * 128.0D / 256.0D / d7;
+
+                    if (d9 < 0.0D) {
+                        d9 *= 4.0D;
+                    }
+
+                    double d10 = this.e[l] / 512.0D;
+                    double d11 = this.f[l] / 512.0D;
+                    double d12 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d13 = MathHelper.b(d10, d11, d12) - d9;
+
+                    if (j2 > 29) {
+                        double d14 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d13 = d13 * (1.0D - d14) + -10.0D * d14;
+                    }
+
+                    this.q[l] = d13;
+                    ++l;
+                }
+            }
+        }
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BiomeBase biomebase = this.n.getBiome(k + 16, l + 16);
+
+        this.i.setSeed(this.n.getSeed());
+        long i1 = this.i.nextLong() / 2L * 2L + 1L;
+        long j1 = this.i.nextLong() / 2L * 2L + 1L;
+
+        this.i.setSeed((long) i * i1 + (long) j * j1 ^ this.n.getSeed());
+        boolean flag = false;
+
+        if (this.o) {
+            this.w.a(this.n, this.i, i, j);
+            flag = this.v.a(this.n, this.i, i, j);
+            this.u.a(this.n, this.i, i, j);
+            this.x.a(this.n, this.i, i, j);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && !flag && this.i.nextInt(4) == 0) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(256);
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.STATIONARY_WATER)).generate(this.n, this.i, k1, l1, i2);
+        }
+
+        if (!flag && this.i.nextInt(8) == 0) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(this.i.nextInt(248) + 8);
+            i2 = l + this.i.nextInt(16) + 8;
+            if (l1 < 63 || this.i.nextInt(10) == 0) {
+                (new WorldGenLakes(Blocks.STATIONARY_LAVA)).generate(this.n, this.i, k1, l1, i2);
+            }
+        }
+
+        for (k1 = 0; k1 < 8; ++k1) {
+            l1 = k + this.i.nextInt(16) + 8;
+            i2 = this.i.nextInt(256);
+            int j2 = l + this.i.nextInt(16) + 8;
+
+            (new WorldGenDungeons()).generate(this.n, this.i, l1, i2, j2);
+        }
+
+        biomebase.a(this.n, this.i, k, l);
+        SpawnerCreature.a(this.n, biomebase, k + 8, l + 8, 16, 16, this.i);
+        k += 8;
+        l += 8;
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                i2 = this.n.h(k + k1, l + l1);
+                if (this.n.r(k1 + k, i2 - 1, l1 + l)) {
+                    this.n.setTypeAndData(k1 + k, i2 - 1, l1 + l, Blocks.ICE, 0, 2);
+                }
+
+                if (this.n.e(k1 + k, i2, l1 + l, true)) {
+                    this.n.setTypeAndData(k1 + k, i2, l1 + l, Blocks.SNOW, 0, 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        BiomeBase biomebase = this.n.getBiome(i, k);
+
+        return enumcreaturetype == EnumCreatureType.MONSTER && this.x.a(i, j, k) ? this.x.b() : biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        return "Stronghold".equals(s) && this.u != null ? this.u.getNearestGeneratedFeature(world, i, j, k) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        if (this.o) {
+            this.w.a(this, this.n, i, j, (Block[]) null);
+            this.v.a(this, this.n, i, j, (Block[]) null);
+            this.u.a(this, this.n, i, j, (Block[]) null);
+            this.x.a(this, this.n, i, j, (Block[]) null);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderHell.java b/src/main/java/net/minecraft/server/ChunkProviderHell.java
new file mode 100644
index 000000000..ef4894e63
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderHell.java
@@ -0,0 +1,445 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class ChunkProviderHell implements IChunkProvider {
+
+    private Random i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGeneratorOctaves l;
+    private NoiseGeneratorOctaves m;
+    private NoiseGeneratorOctaves n;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    private World o;
+    private double[] p;
+    public WorldGenNether c = new WorldGenNether();
+    private double[] q = new double[256];
+    private double[] r = new double[256];
+    private double[] s = new double[256];
+    private WorldGenBase t = new WorldGenCavesHell();
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+    double[] h;
+
+    public ChunkProviderHell(World world, long i) {
+        this.o = world;
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGeneratorOctaves(this.i, 4);
+        this.n = new NoiseGeneratorOctaves(this.i, 4);
+        this.a = new NoiseGeneratorOctaves(this.i, 10);
+        this.b = new NoiseGeneratorOctaves(this.i, 16);
+    }
+
+    public void a(int i, int j, Block[] ablock) {
+        byte b0 = 4;
+        byte b1 = 32;
+        int k = b0 + 1;
+        byte b2 = 17;
+        int l = b0 + 1;
+
+        this.p = this.a(this.p, i * b0, 0, j * b0, k, b2, l);
+
+        for (int i1 = 0; i1 < b0; ++i1) {
+            for (int j1 = 0; j1 < b0; ++j1) {
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[((i1 + 0) * l + j1 + 0) * b2 + k1 + 0];
+                    double d2 = this.p[((i1 + 0) * l + j1 + 1) * b2 + k1 + 0];
+                    double d3 = this.p[((i1 + 1) * l + j1 + 0) * b2 + k1 + 0];
+                    double d4 = this.p[((i1 + 1) * l + j1 + 1) * b2 + k1 + 0];
+                    double d5 = (this.p[((i1 + 0) * l + j1 + 0) * b2 + k1 + 1] - d1) * d0;
+                    double d6 = (this.p[((i1 + 0) * l + j1 + 1) * b2 + k1 + 1] - d2) * d0;
+                    double d7 = (this.p[((i1 + 1) * l + j1 + 0) * b2 + k1 + 1] - d3) * d0;
+                    double d8 = (this.p[((i1 + 1) * l + j1 + 1) * b2 + k1 + 1] - d4) * d0;
+
+                    for (int l1 = 0; l1 < 8; ++l1) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i2 = 0; i2 < 4; ++i2) {
+                            int j2 = i2 + i1 * 4 << 11 | 0 + j1 * 4 << 7 | k1 * 8 + l1;
+                            short short1 = 128;
+                            double d14 = 0.25D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int k2 = 0; k2 < 4; ++k2) {
+                                Block block = null;
+
+                                if (k1 * 8 + l1 < b1) {
+                                    block = Blocks.STATIONARY_LAVA;
+                                }
+
+                                if (d15 > 0.0D) {
+                                    block = Blocks.NETHERRACK;
+                                }
+
+                                ablock[j2] = block;
+                                j2 += short1;
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+    }
+
+    public void b(int i, int j, Block[] ablock) {
+        byte b0 = 64;
+        double d0 = 0.03125D;
+
+        this.q = this.m.a(this.q, i * 16, j * 16, 0, 16, 16, 1, d0, d0, 1.0D);
+        this.r = this.m.a(this.r, i * 16, 109, j * 16, 16, 1, 16, d0, 1.0D, d0);
+        this.s = this.n.a(this.s, i * 16, j * 16, 0, 16, 16, 1, d0 * 2.0D, d0 * 2.0D, d0 * 2.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                boolean flag = this.q[k + l * 16] + this.i.nextDouble() * 0.2D > 0.0D;
+                boolean flag1 = this.r[k + l * 16] + this.i.nextDouble() * 0.2D > 0.0D;
+                int i1 = (int) (this.s[k + l * 16] / 3.0D + 3.0D + this.i.nextDouble() * 0.25D);
+                int j1 = -1;
+                Block block = Blocks.NETHERRACK;
+                Block block1 = Blocks.NETHERRACK;
+
+                for (int k1 = 127; k1 >= 0; --k1) {
+                    int l1 = (l * 16 + k) * 128 + k1;
+
+                    if (k1 < 127 - this.i.nextInt(5) && k1 > 0 + this.i.nextInt(5)) {
+                        Block block2 = ablock[l1];
+
+                        if (block2 != null && block2.getMaterial() != Material.AIR) {
+                            if (block2 == Blocks.NETHERRACK) {
+                                if (j1 == -1) {
+                                    if (i1 <= 0) {
+                                        block = null;
+                                        block1 = Blocks.NETHERRACK;
+                                    } else if (k1 >= b0 - 4 && k1 <= b0 + 1) {
+                                        block = Blocks.NETHERRACK;
+                                        block1 = Blocks.NETHERRACK;
+                                        if (flag1) {
+                                            block = Blocks.GRAVEL;
+                                            block1 = Blocks.NETHERRACK;
+                                        }
+
+                                        if (flag) {
+                                            block = Blocks.SOUL_SAND;
+                                            block1 = Blocks.SOUL_SAND;
+                                        }
+                                    }
+
+                                    if (k1 < b0 && (block == null || block.getMaterial() == Material.AIR)) {
+                                        block = Blocks.STATIONARY_LAVA;
+                                    }
+
+                                    j1 = i1;
+                                    if (k1 >= b0 - 1) {
+                                        ablock[l1] = block;
+                                    } else {
+                                        ablock[l1] = block1;
+                                    }
+                                } else if (j1 > 0) {
+                                    --j1;
+                                    ablock[l1] = block1;
+                                }
+                            }
+                        } else {
+                            j1 = -1;
+                        }
+                    } else {
+                        ablock[l1] = Blocks.BEDROCK;
+                    }
+                }
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        Block[] ablock = new Block['\u8000'];
+
+        this.a(i, j, ablock);
+        this.b(i, j, ablock);
+        this.t.a(this, this.o, i, j, ablock);
+        this.c.a(this, this.o, i, j, ablock);
+        Chunk chunk = new Chunk(this.o, ablock, i, j);
+        BiomeBase[] abiomebase = this.o.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.m();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) abiomebase[k].id;
+        }
+
+        chunk.n();
+        return chunk;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 2053.236D;
+
+        this.g = this.a.a(this.g, i, j, k, l, 1, j1, 1.0D, 0.0D, 1.0D);
+        this.h = this.b.a(this.h, i, j, k, l, 1, j1, 100.0D, 0.0D, 100.0D);
+        this.d = this.l.a(this.d, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 60.0D, d0 / 80.0D);
+        this.e = this.j.a(this.e, i, j, k, l, i1, j1, d0, d1, d0);
+        this.f = this.k.a(this.f, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = 0;
+        int l1 = 0;
+        double[] adouble1 = new double[i1];
+
+        int i2;
+
+        for (i2 = 0; i2 < i1; ++i2) {
+            adouble1[i2] = Math.cos((double) i2 * 3.141592653589793D * 6.0D / (double) i1) * 2.0D;
+            double d2 = (double) i2;
+
+            if (i2 > i1 / 2) {
+                d2 = (double) (i1 - 1 - i2);
+            }
+
+            if (d2 < 4.0D) {
+                d2 = 4.0D - d2;
+                adouble1[i2] -= d2 * d2 * d2 * 10.0D;
+            }
+        }
+
+        for (i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < j1; ++j2) {
+                double d3 = (this.g[l1] + 256.0D) / 512.0D;
+
+                if (d3 > 1.0D) {
+                    d3 = 1.0D;
+                }
+
+                double d4 = 0.0D;
+                double d5 = this.h[l1] / 8000.0D;
+
+                if (d5 < 0.0D) {
+                    d5 = -d5;
+                }
+
+                d5 = d5 * 3.0D - 3.0D;
+                if (d5 < 0.0D) {
+                    d5 /= 2.0D;
+                    if (d5 < -1.0D) {
+                        d5 = -1.0D;
+                    }
+
+                    d5 /= 1.4D;
+                    d5 /= 2.0D;
+                    d3 = 0.0D;
+                } else {
+                    if (d5 > 1.0D) {
+                        d5 = 1.0D;
+                    }
+
+                    d5 /= 6.0D;
+                }
+
+                d3 += 0.5D;
+                d5 = d5 * (double) i1 / 16.0D;
+                ++l1;
+
+                for (int k2 = 0; k2 < i1; ++k2) {
+                    double d6 = 0.0D;
+                    double d7 = adouble1[k2];
+                    double d8 = this.e[k1] / 512.0D;
+                    double d9 = this.f[k1] / 512.0D;
+                    double d10 = (this.d[k1] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d10 < 0.0D) {
+                        d6 = d8;
+                    } else if (d10 > 1.0D) {
+                        d6 = d9;
+                    } else {
+                        d6 = d8 + (d9 - d8) * d10;
+                    }
+
+                    d6 -= d7;
+                    double d11;
+
+                    if (k2 > i1 - 4) {
+                        d11 = (double) ((float) (k2 - (i1 - 4)) / 3.0F);
+                        d6 = d6 * (1.0D - d11) + -10.0D * d11;
+                    }
+
+                    if ((double) k2 < d4) {
+                        d11 = (d4 - (double) k2) / 4.0D;
+                        if (d11 < 0.0D) {
+                            d11 = 0.0D;
+                        }
+
+                        if (d11 > 1.0D) {
+                            d11 = 1.0D;
+                        }
+
+                        d6 = d6 * (1.0D - d11) + -10.0D * d11;
+                    }
+
+                    adouble[k1] = d6;
+                    ++k1;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+
+        this.c.a(this.o, this.i, i, j);
+
+        int i1;
+        int j1;
+        int k1;
+        int l1;
+
+        for (i1 = 0; i1 < 8; ++i1) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(120) + 4;
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenHellLava(Blocks.LAVA, false)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        i1 = this.i.nextInt(this.i.nextInt(10) + 1) + 1;
+
+        int i2;
+
+        for (j1 = 0; j1 < i1; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(120) + 4;
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFire()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        i1 = this.i.nextInt(this.i.nextInt(10) + 1);
+
+        for (j1 = 0; j1 < i1; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(120) + 4;
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLightStone1()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        for (j1 = 0; j1 < 10; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(128);
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLightStone2()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        if (this.i.nextInt(1) == 0) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(128);
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFlowers(Blocks.BROWN_MUSHROOM)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        if (this.i.nextInt(1) == 0) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(128);
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFlowers(Blocks.RED_MUSHROOM)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        WorldGenMinable worldgenminable = new WorldGenMinable(Blocks.QUARTZ_ORE, 13, Blocks.NETHERRACK);
+
+        int j2;
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            l1 = k + this.i.nextInt(16);
+            i2 = this.i.nextInt(108) + 10;
+            j2 = l + this.i.nextInt(16);
+            worldgenminable.generate(this.o, this.i, l1, i2, j2);
+        }
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            l1 = k + this.i.nextInt(16);
+            i2 = this.i.nextInt(108) + 10;
+            j2 = l + this.i.nextInt(16);
+            (new WorldGenHellLava(Blocks.LAVA, true)).generate(this.o, this.i, l1, i2, j2);
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "HellRandomLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        if (enumcreaturetype == EnumCreatureType.MONSTER) {
+            if (this.c.b(i, j, k)) {
+                return this.c.b();
+            }
+
+            if (this.c.d(i, j, k) && this.o.getType(i, j - 1, k) == Blocks.NETHER_BRICK) {
+                return this.c.b();
+            }
+        }
+
+        BiomeBase biomebase = this.o.getBiome(i, k);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        return null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        this.c.a(this, this.o, i, j, (Block[]) null);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/FileIOThread.java b/src/main/java/net/minecraft/server/FileIOThread.java
new file mode 100644
index 000000000..e9c333bfb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/FileIOThread.java
@@ -0,0 +1,70 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class FileIOThread implements Runnable {
+
+    public static final FileIOThread a = new FileIOThread();
+    private List b = Collections.synchronizedList(new ArrayList());
+    private volatile long c;
+    private volatile long d;
+    private volatile boolean e;
+
+    private FileIOThread() {
+        Thread thread = new Thread(this, "File IO Thread");
+
+        thread.setPriority(1);
+        thread.start();
+    }
+
+    public void run() {
+        while (true) {
+    		this.b();
+        }
+    }
+
+    private void b() {
+        for (int i = 0; i < this.b.size(); ++i) {
+            IAsyncChunkSaver iasyncchunksaver = (IAsyncChunkSaver) this.b.get(i);
+            boolean flag = iasyncchunksaver.c();
+
+            if (!flag) {
+                this.b.remove(i--);
+                ++this.d;
+            }
+
+            try {
+                Thread.sleep(this.e ? 0L : 10L);
+            } catch (InterruptedException interruptedexception) {
+                interruptedexception.printStackTrace();
+            }
+        }
+
+        if (this.b.isEmpty()) {
+            try {
+                Thread.sleep(25L);
+            } catch (InterruptedException interruptedexception1) {
+                interruptedexception1.printStackTrace();
+            }
+        }
+    }
+
+    public void a(IAsyncChunkSaver iasyncchunksaver) {
+        if (!this.b.contains(iasyncchunksaver)) {
+            ++this.c;
+            this.b.add(iasyncchunksaver);
+        }
+    }
+
+    public void a() throws InterruptedException {
+        this.e = true;
+
+        while (this.c != this.d) {
+            Thread.sleep(10L);
+        }
+
+        this.e = false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenLayer.java b/src/main/java/net/minecraft/server/GenLayer.java
new file mode 100644
index 000000000..b15e0f608
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenLayer.java
@@ -0,0 +1,168 @@
+package net.minecraft.server;
+
+import java.util.concurrent.Callable;
+
+public abstract class GenLayer {
+
+    private long c;
+    protected GenLayer a;
+    private long d;
+    protected long b;
+
+    public static GenLayer[] a(long i, WorldType worldtype) {
+        boolean flag = false;
+        LayerIsland layerisland = new LayerIsland(1L);
+        GenLayerZoomFuzzy genlayerzoomfuzzy = new GenLayerZoomFuzzy(2000L, layerisland);
+        GenLayerIsland genlayerisland = new GenLayerIsland(1L, genlayerzoomfuzzy);
+        GenLayerZoom genlayerzoom = new GenLayerZoom(2001L, genlayerisland);
+
+        genlayerisland = new GenLayerIsland(2L, genlayerzoom);
+        genlayerisland = new GenLayerIsland(50L, genlayerisland);
+        genlayerisland = new GenLayerIsland(70L, genlayerisland);
+        GenLayerIcePlains genlayericeplains = new GenLayerIcePlains(2L, genlayerisland);
+        GenLayerTopSoil genlayertopsoil = new GenLayerTopSoil(2L, genlayericeplains);
+
+        genlayerisland = new GenLayerIsland(3L, genlayertopsoil);
+        GenLayerSpecial genlayerspecial = new GenLayerSpecial(2L, genlayerisland, EnumGenLayerSpecial.COOL_WARM);
+
+        genlayerspecial = new GenLayerSpecial(2L, genlayerspecial, EnumGenLayerSpecial.HEAT_ICE);
+        genlayerspecial = new GenLayerSpecial(3L, genlayerspecial, EnumGenLayerSpecial.PUFFERFISH);
+        genlayerzoom = new GenLayerZoom(2002L, genlayerspecial);
+        genlayerzoom = new GenLayerZoom(2003L, genlayerzoom);
+        genlayerisland = new GenLayerIsland(4L, genlayerzoom);
+        GenLayerMushroomIsland genlayermushroomisland = new GenLayerMushroomIsland(5L, genlayerisland);
+        GenLayerDeepOcean genlayerdeepocean = new GenLayerDeepOcean(4L, genlayermushroomisland);
+        GenLayer genlayer = GenLayerZoom.b(1000L, genlayerdeepocean, 0);
+        byte b0 = 4;
+
+        if (worldtype == WorldType.LARGE_BIOMES) {
+            b0 = 6;
+        }
+
+        if (flag) {
+            b0 = 4;
+        }
+
+        GenLayer genlayer1 = GenLayerZoom.b(1000L, genlayer, 0);
+        GenLayerCleaner genlayercleaner = new GenLayerCleaner(100L, genlayer1);
+        Object object = new GenLayerBiome(200L, genlayer, worldtype);
+
+        if (!flag) {
+            GenLayer genlayer2 = GenLayerZoom.b(1000L, (GenLayer) object, 2);
+
+            object = new GenLayerDesert(1000L, genlayer2);
+        }
+
+        GenLayer genlayer3 = GenLayerZoom.b(1000L, genlayercleaner, 2);
+        GenLayerRegionHills genlayerregionhills = new GenLayerRegionHills(1000L, (GenLayer) object, genlayer3);
+
+        genlayer1 = GenLayerZoom.b(1000L, genlayercleaner, 2);
+        genlayer1 = GenLayerZoom.b(1000L, genlayer1, b0);
+        GenLayerRiver genlayerriver = new GenLayerRiver(1L, genlayer1);
+        GenLayerSmooth genlayersmooth = new GenLayerSmooth(1000L, genlayerriver);
+
+        object = new GenLayerPlains(1001L, genlayerregionhills);
+
+        for (int j = 0; j < b0; ++j) {
+            object = new GenLayerZoom((long) (1000 + j), (GenLayer) object);
+            if (j == 0) {
+                object = new GenLayerIsland(3L, (GenLayer) object);
+            }
+
+            if (j == 1) {
+                object = new GenLayerMushroomShore(1000L, (GenLayer) object);
+            }
+        }
+
+        GenLayerSmooth genlayersmooth1 = new GenLayerSmooth(1000L, (GenLayer) object);
+        GenLayerRiverMix genlayerrivermix = new GenLayerRiverMix(100L, genlayersmooth1, genlayersmooth);
+        GenLayerZoomVoronoi genlayerzoomvoronoi = new GenLayerZoomVoronoi(10L, genlayerrivermix);
+
+        genlayerrivermix.a(i);
+        genlayerzoomvoronoi.a(i);
+        return new GenLayer[] { genlayerrivermix, genlayerzoomvoronoi, genlayerrivermix};
+    }
+
+    public GenLayer(long i) {
+        this.b = i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+    }
+
+    public void a(long i) {
+        this.c = i;
+        if (this.a != null) {
+            this.a.a(i);
+        }
+
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+    }
+
+    public void a(long i, long j) {
+        this.d = this.c;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += i;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += j;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += i;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += j;
+    }
+
+    protected int a(int i) {
+        int j = (int) ((this.d >> 24) % (long) i);
+
+        if (j < 0) {
+            j += i;
+        }
+
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += this.c;
+        return j;
+    }
+
+    public abstract int[] a(int i, int j, int k, int l);
+
+    protected static boolean a(int i, int j) {
+        if (i == j) {
+            return true;
+        } else if (i != BiomeBase.MESA_PLATEAU_F.id && i != BiomeBase.MESA_PLATEAU.id) {
+            try {
+                return BiomeBase.getBiome(i) != null && BiomeBase.getBiome(j) != null ? BiomeBase.getBiome(i).a(BiomeBase.getBiome(j)) : false;
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Comparing biomes");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Biomes being compared");
+
+                crashreportsystemdetails.a("Biome A ID", Integer.valueOf(i));
+                crashreportsystemdetails.a("Biome B ID", Integer.valueOf(j));
+                crashreportsystemdetails.a("Biome A", (Callable) (new CrashReportGenLayer1(i)));
+                crashreportsystemdetails.a("Biome B", (Callable) (new CrashReportGenLayer2(j)));
+                throw new ReportedException(crashreport);
+            }
+        } else {
+            return j == BiomeBase.MESA_PLATEAU_F.id || j == BiomeBase.MESA_PLATEAU.id;
+        }
+    }
+
+    protected static boolean b(int i) {
+        return i == BiomeBase.OCEAN.id || i == BiomeBase.DEEP_OCEAN.id || i == BiomeBase.FROZEN_OCEAN.id;
+    }
+
+    protected int a(int... aint) {
+        return aint[this.a(aint.length)];
+    }
+
+    protected int b(int i, int j, int k, int l) {
+        return j == k && k == l ? j : (i == j && i == k ? i : (i == j && i == l ? i : (i == k && i == l ? i : (i == j && k != l ? i : (i == k && j != l ? i : (i == l && j != k ? i : (j == k && i != l ? j : (j == l && i != k ? j : (k == l && i != j ? k : this.a(new int[] { i, j, k, l}))))))))));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenLayerBiome.java b/src/main/java/net/minecraft/server/GenLayerBiome.java
new file mode 100644
index 000000000..42fe8f1a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenLayerBiome.java
@@ -0,0 +1,69 @@
+package net.minecraft.server;
+
+public class GenLayerBiome extends GenLayer {
+
+    private BiomeBase[] c;
+    private BiomeBase[] d;
+    private BiomeBase[] e;
+    private BiomeBase[] f;
+
+    public GenLayerBiome(long i, GenLayer genlayer, WorldType worldtype) {
+        super(i);
+        this.c = new BiomeBase[] { BiomeBase.DESERT, BiomeBase.DESERT, BiomeBase.DESERT, BiomeBase.SAVANNA, BiomeBase.SAVANNA, BiomeBase.PLAINS};
+        this.d = new BiomeBase[] { BiomeBase.FOREST, BiomeBase.ROOFED_FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.PLAINS, BiomeBase.BIRCH_FOREST, BiomeBase.SWAMPLAND};
+        this.e = new BiomeBase[] { BiomeBase.FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.TAIGA, BiomeBase.PLAINS};
+        this.f = new BiomeBase[] { BiomeBase.ICE_PLAINS, BiomeBase.ICE_PLAINS, BiomeBase.ICE_PLAINS, BiomeBase.COLD_TAIGA};
+        this.a = genlayer;
+        if (worldtype == WorldType.NORMAL_1_1) {
+            this.c = new BiomeBase[] { BiomeBase.DESERT, BiomeBase.FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.SWAMPLAND, BiomeBase.PLAINS, BiomeBase.TAIGA};
+        }
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i, j, k, l);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + i1 * k];
+                int l1 = (k1 & 3840) >> 8;
+
+                k1 &= -3841;
+                if (b(k1)) {
+                    aint1[j1 + i1 * k] = k1;
+                } else if (k1 == BiomeBase.MUSHROOM_ISLAND.id) {
+                    aint1[j1 + i1 * k] = k1;
+                } else if (k1 == 1) {
+                    if (l1 > 0) {
+                        if (this.a(3) == 0) {
+                            aint1[j1 + i1 * k] = BiomeBase.MESA_PLATEAU.id;
+                        } else {
+                            aint1[j1 + i1 * k] = BiomeBase.MESA_PLATEAU_F.id;
+                        }
+                    } else {
+                        aint1[j1 + i1 * k] = this.c[this.a(this.c.length)].id;
+                    }
+                } else if (k1 == 2) {
+                    if (l1 > 0) {
+                        aint1[j1 + i1 * k] = BiomeBase.JUNGLE.id;
+                    } else {
+                        aint1[j1 + i1 * k] = this.d[this.a(this.d.length)].id;
+                    }
+                } else if (k1 == 3) {
+                    if (l1 > 0) {
+                        aint1[j1 + i1 * k] = BiomeBase.MEGA_TAIGA.id;
+                    } else {
+                        aint1[j1 + i1 * k] = this.e[this.a(this.e.length)].id;
+                    }
+                } else if (k1 == 4) {
+                    aint1[j1 + i1 * k] = this.f[this.a(this.f.length)].id;
+                } else {
+                    aint1[j1 + i1 * k] = BiomeBase.MUSHROOM_ISLAND.id;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenLayerRegionHills.java b/src/main/java/net/minecraft/server/GenLayerRegionHills.java
new file mode 100644
index 000000000..7543f301b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenLayerRegionHills.java
@@ -0,0 +1,131 @@
+package net.minecraft.server;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class GenLayerRegionHills extends GenLayer {
+
+    private static final Logger c = LogManager.getLogger();
+    private GenLayer d;
+
+    public GenLayerRegionHills(long i, GenLayer genlayer, GenLayer genlayer1) {
+        super(i);
+        this.a = genlayer;
+        this.d = genlayer1;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint1 = this.d.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint2 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + 1 + (i1 + 1) * (k + 2)];
+                int l1 = aint1[j1 + 1 + (i1 + 1) * (k + 2)];
+                boolean flag = (l1 - 2) % 29 == 0;
+
+                if (k1 > 255) {
+                    c.debug("old! " + k1);
+                }
+
+                if (k1 != 0 && l1 >= 2 && (l1 - 2) % 29 == 1 && k1 < 128) {
+                    if (BiomeBase.getBiome(k1 + 128) != null) {
+                        aint2[j1 + i1 * k] = k1 + 128;
+                    } else {
+                        aint2[j1 + i1 * k] = k1;
+                    }
+                } else if (this.a(3) != 0 && !flag) {
+                    aint2[j1 + i1 * k] = k1;
+                } else {
+                    int i2 = k1;
+                    int j2;
+
+                    if (k1 == BiomeBase.DESERT.id) {
+                        i2 = BiomeBase.DESERT_HILLS.id;
+                    } else if (k1 == BiomeBase.FOREST.id) {
+                        i2 = BiomeBase.FOREST_HILLS.id;
+                    } else if (k1 == BiomeBase.BIRCH_FOREST.id) {
+                        i2 = BiomeBase.BIRCH_FOREST_HILLS.id;
+                    } else if (k1 == BiomeBase.ROOFED_FOREST.id) {
+                        i2 = BiomeBase.PLAINS.id;
+                    } else if (k1 == BiomeBase.TAIGA.id) {
+                        i2 = BiomeBase.TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.MEGA_TAIGA.id) {
+                        i2 = BiomeBase.MEGA_TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.COLD_TAIGA.id) {
+                        i2 = BiomeBase.COLD_TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.PLAINS.id) {
+                        if (this.a(3) == 0) {
+                            i2 = BiomeBase.FOREST_HILLS.id;
+                        } else {
+                            i2 = BiomeBase.FOREST.id;
+                        }
+                    } else if (k1 == BiomeBase.ICE_PLAINS.id) {
+                        i2 = BiomeBase.ICE_MOUNTAINS.id;
+                    } else if (k1 == BiomeBase.JUNGLE.id) {
+                        i2 = BiomeBase.JUNGLE_HILLS.id;
+                    } else if (k1 == BiomeBase.OCEAN.id) {
+                        i2 = BiomeBase.DEEP_OCEAN.id;
+                    } else if (k1 == BiomeBase.EXTREME_HILLS.id) {
+                        i2 = BiomeBase.EXTREME_HILLS_PLUS.id;
+                    } else if (k1 == BiomeBase.SAVANNA.id) {
+                        i2 = BiomeBase.SAVANNA_PLATEAU.id;
+                    } else if (a(k1, BiomeBase.MESA_PLATEAU_F.id)) {
+                        i2 = BiomeBase.MESA.id;
+                    } else if (k1 == BiomeBase.DEEP_OCEAN.id && this.a(3) == 0) {
+                        j2 = this.a(2);
+                        if (j2 == 0) {
+                            i2 = BiomeBase.PLAINS.id;
+                        } else {
+                            i2 = BiomeBase.FOREST.id;
+                        }
+                    }
+
+                    if (flag && i2 != k1) {
+                        if (BiomeBase.getBiome(i2 + 128) != null) {
+                            i2 += 128;
+                        } else {
+                            i2 = k1;
+                        }
+                    }
+
+                    if (i2 == k1) {
+                        aint2[j1 + i1 * k] = k1;
+                    } else {
+                        j2 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                        int k2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                        int l2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                        int i3 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                        int j3 = 0;
+
+                        if (a(j2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(k2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(l2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(i3, k1)) {
+                            ++j3;
+                        }
+
+                        if (j3 >= 3) {
+                            aint2[j1 + i1 * k] = i2;
+                        } else {
+                            aint2[j1 + i1 * k] = k1;
+                        }
+                    }
+                }
+            }
+        }
+
+        return aint2;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemEgg.java b/src/main/java/net/minecraft/server/ItemEgg.java
new file mode 100644
index 000000000..b74c8fe65
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemEgg.java
@@ -0,0 +1,22 @@
+package net.minecraft.server;
+
+public class ItemEgg extends Item {
+
+    public ItemEgg() {
+        this.maxStackSize = 16;
+        this.a(CreativeModeTab.l);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            --itemstack.count;
+        }
+
+        world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+        if (!world.isStatic) {
+            world.addEntity(new EntityEgg(world, entityhuman));
+        }
+
+        return itemstack;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ItemEnderEye.java b/src/main/java/net/minecraft/server/ItemEnderEye.java
new file mode 100644
index 000000000..91d9770c2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemEnderEye.java
@@ -0,0 +1,134 @@
+package net.minecraft.server;
+
+public class ItemEnderEye extends Item {
+
+    public ItemEnderEye() {
+        this.a(CreativeModeTab.f);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, int i, int j, int k, int l, float f, float f1, float f2) {
+        Block block = world.getType(i, j, k);
+        int i1 = world.getData(i, j, k);
+
+        if (entityhuman.a(i, j, k, l, itemstack) && block == Blocks.ENDER_PORTAL_FRAME && !BlockEnderPortalFrame.b(i1)) {
+            if (world.isStatic) {
+                return true;
+            } else {
+                world.setData(i, j, k, i1 + 4, 2);
+                world.updateAdjacentComparators(i, j, k, Blocks.ENDER_PORTAL_FRAME);
+                --itemstack.count;
+
+                int j1;
+
+                for (j1 = 0; j1 < 16; ++j1) {
+                    double d0 = (double) ((float) i + (5.0F + g.nextFloat() * 6.0F) / 16.0F);
+                    double d1 = (double) ((float) j + 0.8125F);
+                    double d2 = (double) ((float) k + (5.0F + g.nextFloat() * 6.0F) / 16.0F);
+                    double d3 = 0.0D;
+                    double d4 = 0.0D;
+                    double d5 = 0.0D;
+
+                    world.addParticle("smoke", d0, d1, d2, d3, d4, d5);
+                }
+
+                j1 = i1 & 3;
+                int k1 = 0;
+                int l1 = 0;
+                boolean flag = false;
+                boolean flag1 = true;
+                int i2 = Direction.g[j1];
+
+                int j2;
+                int k2;
+                int l2;
+
+                for (l2 = -2; l2 <= 2; ++l2) {
+                    j2 = i + Direction.a[i2] * l2;
+                    k2 = k + Direction.b[i2] * l2;
+                    if (world.getType(j2, j, k2) == Blocks.ENDER_PORTAL_FRAME) {
+                        if (!BlockEnderPortalFrame.b(world.getData(j2, j, k2))) {
+                            flag1 = false;
+                            break;
+                        }
+
+                        l1 = l2;
+                        if (!flag) {
+                            k1 = l2;
+                            flag = true;
+                        }
+                    }
+                }
+
+                if (flag1 && l1 == k1 + 2) {
+                    for (l2 = k1; l2 <= l1; ++l2) {
+                        j2 = i + Direction.a[i2] * l2;
+                        k2 = k + Direction.b[i2] * l2;
+                        j2 += Direction.a[j1] * 4;
+                        k2 += Direction.b[j1] * 4;
+                        if (world.getType(j2, j, k2) != Blocks.ENDER_PORTAL_FRAME || !BlockEnderPortalFrame.b(world.getData(j2, j, k2))) {
+                            flag1 = false;
+                            break;
+                        }
+                    }
+
+                    int i3;
+
+                    for (l2 = k1 - 1; l2 <= l1 + 1; l2 += 4) {
+                        for (j2 = 1; j2 <= 3; ++j2) {
+                            k2 = i + Direction.a[i2] * l2;
+                            i3 = k + Direction.b[i2] * l2;
+                            k2 += Direction.a[j1] * j2;
+                            i3 += Direction.b[j1] * j2;
+                            if (world.getType(k2, j, i3) != Blocks.ENDER_PORTAL_FRAME || !BlockEnderPortalFrame.b(world.getData(k2, j, i3))) {
+                                flag1 = false;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (flag1) {
+                        for (l2 = k1; l2 <= l1; ++l2) {
+                            for (j2 = 1; j2 <= 3; ++j2) {
+                                k2 = i + Direction.a[i2] * l2;
+                                i3 = k + Direction.b[i2] * l2;
+                                k2 += Direction.a[j1] * j2;
+                                i3 += Direction.b[j1] * j2;
+                                world.setTypeAndData(k2, j, i3, Blocks.ENDER_PORTAL, 0, 2);
+                            }
+                        }
+                    }
+                }
+
+                return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        MovingObjectPosition movingobjectposition = this.a(world, entityhuman, false);
+
+        if (movingobjectposition != null && movingobjectposition.type == EnumMovingObjectType.BLOCK && world.getType(movingobjectposition.b, movingobjectposition.c, movingobjectposition.d) == Blocks.ENDER_PORTAL_FRAME) {
+            return itemstack;
+        } else {
+            if (!world.isStatic) {
+                ChunkPosition chunkposition = world.b("Stronghold", (int) entityhuman.locX, (int) entityhuman.locY, (int) entityhuman.locZ);
+
+                if (chunkposition != null) {
+                    EntityEnderSignal entityendersignal = new EntityEnderSignal(world, entityhuman.locX, entityhuman.locY + 1.62D - (double) entityhuman.height, entityhuman.locZ);
+
+                    entityendersignal.a((double) chunkposition.x, chunkposition.y, (double) chunkposition.z);
+                    world.addEntity(entityendersignal);
+                    world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+                    world.a((EntityHuman) null, 1002, (int) entityhuman.locX, (int) entityhuman.locY, (int) entityhuman.locZ, 0);
+                    if (!entityhuman.abilities.canInstantlyBuild) {
+                        --itemstack.count;
+                    }
+                }
+            }
+
+            return itemstack;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemEnderPearl.java b/src/main/java/net/minecraft/server/ItemEnderPearl.java
new file mode 100644
index 000000000..2fe9c3c6c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemEnderPearl.java
@@ -0,0 +1,23 @@
+package net.minecraft.server;
+
+public class ItemEnderPearl extends Item {
+
+    public ItemEnderPearl() {
+        this.maxStackSize = 16;
+        this.a(CreativeModeTab.f);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (entityhuman.abilities.canInstantlyBuild) {
+            return itemstack;
+        } else {
+            --itemstack.count;
+            world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+            if (!world.isStatic) {
+                world.addEntity(new EntityEnderPearl(world, entityhuman));
+            }
+
+            return itemstack;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ItemExpBottle.java b/src/main/java/net/minecraft/server/ItemExpBottle.java
new file mode 100644
index 000000000..a7eba06db
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemExpBottle.java
@@ -0,0 +1,21 @@
+package net.minecraft.server;
+
+public class ItemExpBottle extends Item {
+
+    public ItemExpBottle() {
+        this.a(CreativeModeTab.f);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            --itemstack.count;
+        }
+
+        world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+        if (!world.isStatic) {
+            world.addEntity(new EntityThrownExpBottle(world, entityhuman));
+        }
+
+        return itemstack;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ItemFireworks.java b/src/main/java/net/minecraft/server/ItemFireworks.java
new file mode 100644
index 000000000..ad61d22a2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemFireworks.java
@@ -0,0 +1,21 @@
+package net.minecraft.server;
+
+public class ItemFireworks extends Item {
+
+    public ItemFireworks() {}
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, int i, int j, int k, int l, float f, float f1, float f2) {
+        if (!world.isStatic) {
+            EntityFireworks entityfireworks = new EntityFireworks(world, (double) ((float) i + f), (double) ((float) j + f1), (double) ((float) k + f2), itemstack);
+
+            world.addEntity(entityfireworks);
+            if (!entityhuman.abilities.canInstantlyBuild) {
+                --itemstack.count;
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ItemMilkBucket.java b/src/main/java/net/minecraft/server/ItemMilkBucket.java
new file mode 100644
index 000000000..39f1bc031
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemMilkBucket.java
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+public class ItemMilkBucket extends Item {
+
+    public ItemMilkBucket() {
+        this.e(1);
+        this.a(CreativeModeTab.f);
+    }
+
+    public ItemStack b(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            --itemstack.count;
+        }
+
+        if (!world.isStatic) {
+            entityhuman.removeAllEffects();
+        }
+
+        return itemstack.count <= 0 ? new ItemStack(Items.BUCKET) : itemstack;
+    }
+
+    public int d_(ItemStack itemstack) {
+        return 32;
+    }
+
+    public EnumAnimation d(ItemStack itemstack) {
+        return EnumAnimation.DRINK;
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        entityhuman.a(itemstack, this.d_(itemstack));
+        return itemstack;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemPotion.java b/src/main/java/net/minecraft/server/ItemPotion.java
new file mode 100644
index 000000000..120bf1ce3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemPotion.java
@@ -0,0 +1,147 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+public class ItemPotion extends Item {
+
+    private HashMap a = new HashMap();
+    private static final Map b = new LinkedHashMap();
+
+    public ItemPotion() {
+        this.e(1);
+        this.a(true);
+        this.setMaxDurability(0);
+        this.a(CreativeModeTab.k);
+    }
+
+    public List g(ItemStack itemstack) {
+        if (itemstack.hasTag() && itemstack.getTag().hasKeyOfType("CustomPotionEffects", 9)) {
+            ArrayList arraylist = new ArrayList();
+            NBTTagList nbttaglist = itemstack.getTag().getList("CustomPotionEffects", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                NBTTagCompound nbttagcompound = nbttaglist.get(i);
+                MobEffect mobeffect = MobEffect.b(nbttagcompound);
+
+                if (mobeffect != null) {
+                    arraylist.add(mobeffect);
+                }
+            }
+
+            return arraylist;
+        } else {
+            List list = (List) this.a.get(Integer.valueOf(itemstack.getData()));
+
+            if (list == null) {
+                list = PotionBrewer.getEffects(itemstack.getData(), false);
+                this.a.put(Integer.valueOf(itemstack.getData()), list);
+            }
+
+            return list;
+        }
+    }
+
+    public List c(int i) {
+        List list = (List) this.a.get(Integer.valueOf(i));
+
+        if (list == null) {
+            list = PotionBrewer.getEffects(i, false);
+            this.a.put(Integer.valueOf(i), list);
+        }
+
+        return list;
+    }
+
+    public ItemStack b(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            --itemstack.count;
+        }
+
+        if (!world.isStatic) {
+            List list = this.g(itemstack);
+
+            if (list != null) {
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    MobEffect mobeffect = (MobEffect) iterator.next();
+
+                    entityhuman.addEffect(new MobEffect(mobeffect));
+                }
+            }
+        }
+
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            if (itemstack.count <= 0) {
+                return new ItemStack(Items.GLASS_BOTTLE);
+            }
+
+            entityhuman.inventory.pickup(new ItemStack(Items.GLASS_BOTTLE));
+        }
+
+        return itemstack;
+    }
+
+    public int d_(ItemStack itemstack) {
+        return 32;
+    }
+
+    public EnumAnimation d(ItemStack itemstack) {
+        return EnumAnimation.DRINK;
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (g(itemstack.getData())) {
+            if (!entityhuman.abilities.canInstantlyBuild) {
+                --itemstack.count;
+            }
+
+            world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+            if (!world.isStatic) {
+                world.addEntity(new EntityPotion(world, entityhuman, itemstack));
+            }
+
+            return itemstack;
+        } else {
+            entityhuman.a(itemstack, this.d_(itemstack));
+            return itemstack;
+        }
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, int i, int j, int k, int l, float f, float f1, float f2) {
+        return false;
+    }
+
+    public static boolean g(int i) {
+        return (i & 16384) != 0;
+    }
+
+    public String n(ItemStack itemstack) {
+        if (itemstack.getData() == 0) {
+            return LocaleI18n.get("item.emptyPotion.name").trim();
+        } else {
+            String s = "";
+
+            if (g(itemstack.getData())) {
+                s = LocaleI18n.get("potion.prefix.grenade").trim() + " ";
+            }
+
+            List list = Items.POTION.g(itemstack);
+            String s1;
+
+            if (list != null && !list.isEmpty()) {
+                s1 = ((MobEffect) list.get(0)).f();
+                s1 = s1 + ".postfix";
+                return s + LocaleI18n.get(s1).trim();
+            } else {
+                s1 = PotionBrewer.c(itemstack.getData());
+                return LocaleI18n.get(s1).trim() + " " + super.n(itemstack);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ItemSnowball.java b/src/main/java/net/minecraft/server/ItemSnowball.java
new file mode 100644
index 000000000..fb5e8536d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSnowball.java
@@ -0,0 +1,22 @@
+package net.minecraft.server;
+
+public class ItemSnowball extends Item {
+
+    public ItemSnowball() {
+        this.maxStackSize = 16;
+        this.a(CreativeModeTab.f);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            --itemstack.count;
+        }
+
+        world.makeSound(entityhuman, "random.bow", 0.5F, 0.4F / (g.nextFloat() * 0.4F + 0.8F));
+        if (!world.isStatic) {
+            world.addEntity(new EntitySnowball(world, entityhuman));
+        }
+
+        return itemstack;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/LayerIsland.java b/src/main/java/net/minecraft/server/LayerIsland.java
new file mode 100644
index 000000000..8a21033cc
--- /dev/null
+++ b/src/main/java/net/minecraft/server/LayerIsland.java
@@ -0,0 +1,25 @@
+package net.minecraft.server;
+
+public class LayerIsland extends GenLayer {
+
+    public LayerIsland(long i) {
+        super(i);
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (i + j1), (long) (j + i1));
+                aint[j1 + i1 * k] = this.a(10) == 0 ? 1 : 0;
+            }
+        }
+
+        if (i > -k && i <= 0 && j > -l && j <= 0) {
+            aint[-i + -j * k] = 1;
+        }
+
+        return aint;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MobEffectAttackDamage.java b/src/main/java/net/minecraft/server/MobEffectAttackDamage.java
new file mode 100644
index 000000000..3eb029d46
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MobEffectAttackDamage.java
@@ -0,0 +1,12 @@
+package net.minecraft.server;
+
+public class MobEffectAttackDamage extends MobEffectList {
+
+    protected MobEffectAttackDamage(int i, boolean flag, int j) {
+        super(i, flag, j);
+    }
+
+    public double a(int i, AttributeModifier attributemodifier) {
+        return this.id == MobEffectList.WEAKNESS.id ? (double) (-0.5F * (float) (i + 1)) : 1.3D * (double) (i + 1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagList.java b/src/main/java/net/minecraft/server/NBTTagList.java
new file mode 100644
index 000000000..bdde30a29
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagList.java
@@ -0,0 +1,168 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class NBTTagList extends NBTBase {
+
+    private List list = new ArrayList();
+    private byte type = 0;
+
+    public NBTTagList() {}
+
+    void write(DataOutput dataoutput) throws IOException {
+        if (!this.list.isEmpty()) {
+            this.type = ((NBTBase) this.list.get(0)).getTypeId();
+        } else {
+            this.type = 0;
+        }
+
+        dataoutput.writeByte(this.type);
+        dataoutput.writeInt(this.list.size());
+
+        for (int i = 0; i < this.list.size(); ++i) {
+            ((NBTBase) this.list.get(i)).write(dataoutput);
+        }
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            nbtreadlimiter.a(8L);
+            this.type = datainput.readByte();
+            int j = datainput.readInt();
+
+            this.list = new ArrayList();
+
+            for (int k = 0; k < j; ++k) {
+                NBTBase nbtbase = NBTBase.createTag(this.type);
+
+                nbtbase.load(datainput, i + 1, nbtreadlimiter);
+                this.list.add(nbtbase);
+            }
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 9;
+    }
+
+    public String toString() {
+        String s = "[";
+        int i = 0;
+
+        for (Iterator iterator = this.list.iterator(); iterator.hasNext(); ++i) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+
+            s = s + "" + i + ':' + nbtbase + ',';
+        }
+
+        return s + "]";
+    }
+
+    public void add(NBTBase nbtbase) {
+        if (this.type == 0) {
+            this.type = nbtbase.getTypeId();
+        } else if (this.type != nbtbase.getTypeId()) {
+            System.err.println("WARNING: Adding mismatching tag types to tag list");
+            return;
+        }
+
+        this.list.add(nbtbase);
+    }
+
+    public NBTTagCompound get(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 10 ? (NBTTagCompound) nbtbase : new NBTTagCompound();
+        } else {
+            return new NBTTagCompound();
+        }
+    }
+
+    public int[] c(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 11 ? ((NBTTagIntArray) nbtbase).c() : new int[0];
+        } else {
+            return new int[0];
+        }
+    }
+
+    public double d(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 6 ? ((NBTTagDouble) nbtbase).g() : 0.0D;
+        } else {
+            return 0.0D;
+        }
+    }
+
+    public float e(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 5 ? ((NBTTagFloat) nbtbase).h() : 0.0F;
+        } else {
+            return 0.0F;
+        }
+    }
+
+    public String getString(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 8 ? nbtbase.a_() : nbtbase.toString();
+        } else {
+            return "";
+        }
+    }
+
+    public int size() {
+        return this.list.size();
+    }
+
+    public NBTBase clone() {
+        NBTTagList nbttaglist = new NBTTagList();
+
+        nbttaglist.type = this.type;
+        Iterator iterator = this.list.iterator();
+
+        while (iterator.hasNext()) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+            NBTBase nbtbase1 = nbtbase.clone();
+
+            nbttaglist.list.add(nbtbase1);
+        }
+
+        return nbttaglist;
+    }
+
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagList nbttaglist = (NBTTagList) object;
+
+            if (this.type == nbttaglist.type) {
+                return this.list.equals(nbttaglist.list);
+            }
+        }
+
+        return false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.list.hashCode();
+    }
+
+    public int d() {
+        return this.type;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagString.java b/src/main/java/net/minecraft/server/NBTTagString.java
new file mode 100644
index 000000000..9b0697965
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagString.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagString extends NBTBase {
+
+    private String data;
+
+    public NBTTagString() {
+        this.data = "";
+    }
+
+    public NBTTagString(String s) {
+        this.data = s;
+        if (s == null) {
+            throw new IllegalArgumentException("Empty string not allowed");
+        }
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeUTF(this.data);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        this.data = datainput.readUTF();
+        nbtreadlimiter.a((long) (16 * this.data.length()));
+    }
+
+    public byte getTypeId() {
+        return (byte) 8;
+    }
+
+    public String toString() {
+        return "\"" + this.data + "\"";
+    }
+
+    public NBTBase clone() {
+        return new NBTTagString(this.data);
+    }
+
+    public boolean equals(Object object) {
+        if (!super.equals(object)) {
+            return false;
+        } else {
+            NBTTagString nbttagstring = (NBTTagString) object;
+
+            return this.data == null && nbttagstring.data == null || this.data != null && this.data.equals(nbttagstring.data);
+        }
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.data.hashCode();
+    }
+
+    public String a_() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Navigation.java b/src/main/java/net/minecraft/server/Navigation.java
new file mode 100644
index 000000000..7002621b1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Navigation.java
@@ -0,0 +1,348 @@
+package net.minecraft.server;
+
+public class Navigation {
+
+    private EntityInsentient a;
+    private World b;
+    private PathEntity c;
+    private double d;
+    private AttributeInstance e;
+    private boolean f;
+    private int g;
+    private int h;
+    private Vec3D i = Vec3D.a(0.0D, 0.0D, 0.0D);
+    private boolean j = true;
+    private boolean k;
+    private boolean l;
+    private boolean m;
+
+    public Navigation(EntityInsentient entityinsentient, World world) {
+        this.a = entityinsentient;
+        this.b = world;
+        this.e = entityinsentient.getAttributeInstance(GenericAttributes.b);
+    }
+
+    public void a(boolean flag) {
+        this.l = flag;
+    }
+
+    public boolean a() {
+        return this.l;
+    }
+
+    public void b(boolean flag) {
+        this.k = flag;
+    }
+
+    public void c(boolean flag) {
+        this.j = flag;
+    }
+
+    public boolean c() {
+        return this.k;
+    }
+
+    public void d(boolean flag) {
+        this.f = flag;
+    }
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public void e(boolean flag) {
+        this.m = flag;
+    }
+
+    public float d() {
+        return (float) this.e.getValue();
+    }
+
+    public PathEntity a(double d0, double d1, double d2) {
+        return !this.l() ? null : this.b.a(this.a, MathHelper.floor(d0), (int) d1, MathHelper.floor(d2), this.d(), this.j, this.k, this.l, this.m);
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        PathEntity pathentity = this.a((double) MathHelper.floor(d0), (double) ((int) d1), (double) MathHelper.floor(d2));
+
+        return this.a(pathentity, d3);
+    }
+
+    public PathEntity a(Entity entity) {
+        return !this.l() ? null : this.b.findPath(this.a, entity, this.d(), this.j, this.k, this.l, this.m);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null ? this.a(pathentity, d0) : false;
+    }
+
+    public boolean a(PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            if (this.f) {
+                this.n();
+            }
+
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.j();
+
+                this.h = this.g;
+                this.i.a = vec3d.a;
+                this.i.b = vec3d.b;
+                this.i.c = vec3d.c;
+                return true;
+            }
+        }
+    }
+
+    public PathEntity e() {
+        return this.c;
+    }
+
+    public void f() {
+        ++this.g;
+        if (!this.g()) {
+            if (this.l()) {
+                this.i();
+            }
+
+            if (!this.g()) {
+                Vec3D vec3d = this.c.a((Entity) this.a);
+
+                if (vec3d != null) {
+                    this.a.getControllerMove().a(vec3d.a, vec3d.b, vec3d.c, this.d);
+                }
+            }
+        }
+    }
+
+    private void i() {
+        Vec3D vec3d = this.j();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if (this.c.a(j).b != (int) vec3d.b) {
+                i = j;
+                break;
+            }
+        }
+
+        float f = this.a.width * this.a.width;
+
+        int k;
+
+        for (k = this.c.e(); k < i; ++k) {
+            if (vec3d.distanceSquared(this.c.a(this.a, k)) < (double) f) {
+                this.c.c(k + 1);
+            }
+        }
+
+        k = MathHelper.f(this.a.width);
+        int l = (int) this.a.length + 1;
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        if (this.g - this.h > 100) {
+            if (vec3d.distanceSquared(this.i) < 2.25D) {
+                this.h();
+            }
+
+            this.h = this.g;
+            this.i.a = vec3d.a;
+            this.i.b = vec3d.b;
+            this.i.c = vec3d.c;
+        }
+    }
+
+    public boolean g() {
+        return this.c == null || this.c.b();
+    }
+
+    public void h() {
+        this.c = null;
+    }
+
+    private Vec3D j() {
+        return Vec3D.a(this.a.locX, (double) this.k(), this.a.locZ);
+    }
+
+    private int k() {
+        if (this.a.M() && this.m) {
+            int i = (int) this.a.boundingBox.b;
+            Block block = this.b.getType(MathHelper.floor(this.a.locX), i, MathHelper.floor(this.a.locZ));
+            int j = 0;
+
+            do {
+                if (block != Blocks.WATER && block != Blocks.STATIONARY_WATER) {
+                    return i;
+                }
+
+                ++i;
+                block = this.b.getType(MathHelper.floor(this.a.locX), i, MathHelper.floor(this.a.locZ));
+                ++j;
+            } while (j <= 16);
+
+            return (int) this.a.boundingBox.b;
+        } else {
+            return (int) (this.a.boundingBox.b + 0.5D);
+        }
+    }
+
+    private boolean l() {
+        return this.a.onGround || this.m && this.m() || this.a.am() && this.a instanceof EntityZombie && this.a.vehicle instanceof EntityChicken;
+    }
+
+    private boolean m() {
+        return this.a.M() || this.a.P();
+    }
+
+    private void n() {
+        if (!this.b.i(MathHelper.floor(this.a.locX), (int) (this.a.boundingBox.b + 0.5D), MathHelper.floor(this.a.locZ))) {
+            for (int i = 0; i < this.c.d(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+
+                if (this.b.i(pathpoint.a, pathpoint.b, pathpoint.c)) {
+                    this.c.b(i - 1);
+                    return;
+                }
+            }
+        }
+    }
+
+    private boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k) {
+        int l = MathHelper.floor(vec3d.a);
+        int i1 = MathHelper.floor(vec3d.c);
+        double d0 = vec3d1.a - vec3d.a;
+        double d1 = vec3d1.c - vec3d.c;
+        double d2 = d0 * d0 + d1 * d1;
+
+        if (d2 < 1.0E-8D) {
+            return false;
+        } else {
+            double d3 = 1.0D / Math.sqrt(d2);
+
+            d0 *= d3;
+            d1 *= d3;
+            i += 2;
+            k += 2;
+            if (!this.a(l, (int) vec3d.b, i1, i, j, k, vec3d, d0, d1)) {
+                return false;
+            } else {
+                i -= 2;
+                k -= 2;
+                double d4 = 1.0D / Math.abs(d0);
+                double d5 = 1.0D / Math.abs(d1);
+                double d6 = (double) (l * 1) - vec3d.a;
+                double d7 = (double) (i1 * 1) - vec3d.c;
+
+                if (d0 >= 0.0D) {
+                    ++d6;
+                }
+
+                if (d1 >= 0.0D) {
+                    ++d7;
+                }
+
+                d6 /= d0;
+                d7 /= d1;
+                int j1 = d0 < 0.0D ? -1 : 1;
+                int k1 = d1 < 0.0D ? -1 : 1;
+                int l1 = MathHelper.floor(vec3d1.a);
+                int i2 = MathHelper.floor(vec3d1.c);
+                int j2 = l1 - l;
+                int k2 = i2 - i1;
+
+                do {
+                    if (j2 * j1 <= 0 && k2 * k1 <= 0) {
+                        return true;
+                    }
+
+                    if (d6 < d7) {
+                        d6 += d4;
+                        l += j1;
+                        j2 = l1 - l;
+                    } else {
+                        d7 += d5;
+                        i1 += k1;
+                        k2 = i2 - i1;
+                    }
+                } while (this.a(l, (int) vec3d.b, i1, i, j, k, vec3d, d0, d1));
+
+                return false;
+            }
+        }
+    }
+
+    private boolean a(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        int k1 = i - l / 2;
+        int l1 = k - j1 / 2;
+
+        if (!this.b(k1, j, l1, l, i1, j1, vec3d, d0, d1)) {
+            return false;
+        } else {
+            for (int i2 = k1; i2 < k1 + l; ++i2) {
+                for (int j2 = l1; j2 < l1 + j1; ++j2) {
+                    double d2 = (double) i2 + 0.5D - vec3d.a;
+                    double d3 = (double) j2 + 0.5D - vec3d.c;
+
+                    if (d2 * d0 + d3 * d1 >= 0.0D) {
+                        Block block = this.b.getType(i2, j - 1, j2);
+                        Material material = block.getMaterial();
+
+                        if (material == Material.AIR) {
+                            return false;
+                        }
+
+                        if (material == Material.WATER && !this.a.M()) {
+                            return false;
+                        }
+
+                        if (material == Material.LAVA) {
+                            return false;
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+
+    private boolean b(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        for (int k1 = i; k1 < i + l; ++k1) {
+            for (int l1 = j; l1 < j + i1; ++l1) {
+                for (int i2 = k; i2 < k + j1; ++i2) {
+                    double d2 = (double) k1 + 0.5D - vec3d.a;
+                    double d3 = (double) i2 + 0.5D - vec3d.c;
+
+                    if (d2 * d0 + d3 * d1 >= 0.0D) {
+                        Block block = this.b.getType(k1, l1, i2);
+
+                        if (!block.b(this.b, k1, l1, i2)) {
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Pathfinder.java b/src/main/java/net/minecraft/server/Pathfinder.java
new file mode 100644
index 000000000..de9593976
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Pathfinder.java
@@ -0,0 +1,283 @@
+package net.minecraft.server;
+
+public class Pathfinder {
+
+    private IBlockAccess a;
+    private Path b = new Path();
+    private IntHashMap c = new IntHashMap();
+    private PathPoint[] d = new PathPoint[32];
+    private boolean e;
+    private boolean f;
+    private boolean g;
+    private boolean h;
+
+    public Pathfinder(IBlockAccess iblockaccess, boolean flag, boolean flag1, boolean flag2, boolean flag3) {
+        this.a = iblockaccess;
+        this.e = flag;
+        this.f = flag1;
+        this.g = flag2;
+        this.h = flag3;
+    }
+
+    public PathEntity a(Entity entity, Entity entity1, float f) {
+        return this.a(entity, entity1.locX, entity1.boundingBox.b, entity1.locZ, f);
+    }
+
+    public PathEntity a(Entity entity, int i, int j, int k, float f) {
+        return this.a(entity, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), f);
+    }
+
+    private PathEntity a(Entity entity, double d0, double d1, double d2, float f) {
+        this.b.a();
+        this.c.c();
+        boolean flag = this.g;
+        int i = MathHelper.floor(entity.boundingBox.b + 0.5D);
+
+        if (this.h && entity.M()) {
+            i = (int) entity.boundingBox.b;
+
+            for (Block block = this.a.getType(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ)); block == Blocks.WATER || block == Blocks.STATIONARY_WATER; block = this.a.getType(MathHelper.floor(entity.locX), i, MathHelper.floor(entity.locZ))) {
+                ++i;
+            }
+
+            flag = this.g;
+            this.g = false;
+        } else {
+            i = MathHelper.floor(entity.boundingBox.b + 0.5D);
+        }
+
+        PathPoint pathpoint = this.a(MathHelper.floor(entity.boundingBox.a), i, MathHelper.floor(entity.boundingBox.c));
+        PathPoint pathpoint1 = this.a(MathHelper.floor(d0 - (double) (entity.width / 2.0F)), MathHelper.floor(d1), MathHelper.floor(d2 - (double) (entity.width / 2.0F)));
+        PathPoint pathpoint2 = new PathPoint(MathHelper.d(entity.width + 1.0F), MathHelper.d(entity.length + 1.0F), MathHelper.d(entity.width + 1.0F));
+        PathEntity pathentity = this.a(entity, pathpoint, pathpoint1, pathpoint2, f);
+
+        this.g = flag;
+        return pathentity;
+    }
+
+    private PathEntity a(Entity entity, PathPoint pathpoint, PathPoint pathpoint1, PathPoint pathpoint2, float f) {
+        pathpoint.e = 0.0F;
+        pathpoint.f = pathpoint.b(pathpoint1);
+        pathpoint.g = pathpoint.f;
+        this.b.a();
+        this.b.a(pathpoint);
+        PathPoint pathpoint3 = pathpoint;
+
+        while (!this.b.e()) {
+            PathPoint pathpoint4 = this.b.c();
+
+            if (pathpoint4.equals(pathpoint1)) {
+                return this.a(pathpoint, pathpoint1);
+            }
+
+            if (pathpoint4.b(pathpoint1) < pathpoint3.b(pathpoint1)) {
+                pathpoint3 = pathpoint4;
+            }
+
+            pathpoint4.i = true;
+            int i = this.b(entity, pathpoint4, pathpoint2, pathpoint1, f);
+
+            for (int j = 0; j < i; ++j) {
+                PathPoint pathpoint5 = this.d[j];
+                float f1 = pathpoint4.e + pathpoint4.b(pathpoint5);
+
+                if (!pathpoint5.a() || f1 < pathpoint5.e) {
+                    pathpoint5.h = pathpoint4;
+                    pathpoint5.e = f1;
+                    pathpoint5.f = pathpoint5.b(pathpoint1);
+                    if (pathpoint5.a()) {
+                        this.b.a(pathpoint5, pathpoint5.e + pathpoint5.f);
+                    } else {
+                        pathpoint5.g = pathpoint5.e + pathpoint5.f;
+                        this.b.a(pathpoint5);
+                    }
+                }
+            }
+        }
+
+        if (pathpoint3 == pathpoint) {
+            return null;
+        } else {
+            return this.a(pathpoint, pathpoint3);
+        }
+    }
+
+    private int b(Entity entity, PathPoint pathpoint, PathPoint pathpoint1, PathPoint pathpoint2, float f) {
+        int i = 0;
+        byte b0 = 0;
+
+        if (this.a(entity, pathpoint.a, pathpoint.b + 1, pathpoint.c, pathpoint1) == 1) {
+            b0 = 1;
+        }
+
+        PathPoint pathpoint3 = this.a(entity, pathpoint.a, pathpoint.b, pathpoint.c + 1, pathpoint1, b0);
+        PathPoint pathpoint4 = this.a(entity, pathpoint.a - 1, pathpoint.b, pathpoint.c, pathpoint1, b0);
+        PathPoint pathpoint5 = this.a(entity, pathpoint.a + 1, pathpoint.b, pathpoint.c, pathpoint1, b0);
+        PathPoint pathpoint6 = this.a(entity, pathpoint.a, pathpoint.b, pathpoint.c - 1, pathpoint1, b0);
+
+        if (pathpoint3 != null && !pathpoint3.i && pathpoint3.a(pathpoint2) < f) {
+            this.d[i++] = pathpoint3;
+        }
+
+        if (pathpoint4 != null && !pathpoint4.i && pathpoint4.a(pathpoint2) < f) {
+            this.d[i++] = pathpoint4;
+        }
+
+        if (pathpoint5 != null && !pathpoint5.i && pathpoint5.a(pathpoint2) < f) {
+            this.d[i++] = pathpoint5;
+        }
+
+        if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint2) < f) {
+            this.d[i++] = pathpoint6;
+        }
+
+        return i;
+    }
+
+    private PathPoint a(Entity entity, int i, int j, int k, PathPoint pathpoint, int l) {
+        PathPoint pathpoint1 = null;
+        int i1 = this.a(entity, i, j, k, pathpoint);
+
+        if (i1 == 2) {
+            return this.a(i, j, k);
+        } else {
+            if (i1 == 1) {
+                pathpoint1 = this.a(i, j, k);
+            }
+
+            if (pathpoint1 == null && l > 0 && i1 != -3 && i1 != -4 && this.a(entity, i, j + l, k, pathpoint) == 1) {
+                pathpoint1 = this.a(i, j + l, k);
+                j += l;
+            }
+
+            if (pathpoint1 != null) {
+                int j1 = 0;
+                int k1 = 0;
+
+                while (j > 0) {
+                    k1 = this.a(entity, i, j - 1, k, pathpoint);
+                    if (this.g && k1 == -1) {
+                        return null;
+                    }
+
+                    if (k1 != 1) {
+                        break;
+                    }
+
+                    if (j1++ >= entity.ax()) {
+                        return null;
+                    }
+
+                    --j;
+                    if (j > 0) {
+                        pathpoint1 = this.a(i, j, k);
+                    }
+                }
+
+                if (k1 == -2) {
+                    return null;
+                }
+            }
+
+            return pathpoint1;
+        }
+    }
+
+    private final PathPoint a(int i, int j, int k) {
+        int l = PathPoint.a(i, j, k);
+        PathPoint pathpoint = (PathPoint) this.c.get(l);
+
+        if (pathpoint == null) {
+            pathpoint = new PathPoint(i, j, k);
+            this.c.a(l, pathpoint);
+        }
+
+        return pathpoint;
+    }
+
+    public int a(Entity entity, int i, int j, int k, PathPoint pathpoint) {
+        return a(entity, i, j, k, pathpoint, this.g, this.f, this.e);
+    }
+
+    public static int a(Entity entity, int i, int j, int k, PathPoint pathpoint, boolean flag, boolean flag1, boolean flag2) {
+        boolean flag3 = false;
+
+        for (int l = i; l < i + pathpoint.a; ++l) {
+            for (int i1 = j; i1 < j + pathpoint.b; ++i1) {
+                for (int j1 = k; j1 < k + pathpoint.c; ++j1) {
+                    Block block = entity.world.getType(l, i1, j1);
+
+                    if (block.getMaterial() != Material.AIR) {
+                        if (block == Blocks.TRAP_DOOR) {
+                            flag3 = true;
+                        } else if (block != Blocks.WATER && block != Blocks.STATIONARY_WATER) {
+                            if (!flag2 && block == Blocks.WOODEN_DOOR) {
+                                return 0;
+                            }
+                        } else {
+                            if (flag) {
+                                return -1;
+                            }
+
+                            flag3 = true;
+                        }
+
+                        int k1 = block.b();
+
+                        if (entity.world.getType(l, i1, j1).b() == 9) {
+                            int l1 = MathHelper.floor(entity.locX);
+                            int i2 = MathHelper.floor(entity.locY);
+                            int j2 = MathHelper.floor(entity.locZ);
+
+                            if (entity.world.getType(l1, i2, j2).b() != 9 && entity.world.getType(l1, i2 - 1, j2).b() != 9) {
+                                return -3;
+                            }
+                        } else if (!block.b(entity.world, l, i1, j1) && (!flag1 || block != Blocks.WOODEN_DOOR)) {
+                            if (k1 == 11 || block == Blocks.FENCE_GATE || k1 == 32) {
+                                return -3;
+                            }
+
+                            if (block == Blocks.TRAP_DOOR) {
+                                return -4;
+                            }
+
+                            Material material = block.getMaterial();
+
+                            if (material != Material.LAVA) {
+                                return 0;
+                            }
+
+                            if (!entity.P()) {
+                                return -2;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return flag3 ? 2 : 1;
+    }
+
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1) {
+        int i = 1;
+
+        PathPoint pathpoint2;
+
+        for (pathpoint2 = pathpoint1; pathpoint2.h != null; pathpoint2 = pathpoint2.h) {
+            ++i;
+        }
+
+        PathPoint[] apathpoint = new PathPoint[i];
+
+        pathpoint2 = pathpoint1;
+        --i;
+
+        for (apathpoint[i] = pathpoint1; pathpoint2.h != null; apathpoint[i] = pathpoint2) {
+            pathpoint2 = pathpoint2.h;
+            --i;
+        }
+
+        return new PathEntity(apathpoint);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalAvoidPlayer.java b/src/main/java/net/minecraft/server/PathfinderGoalAvoidPlayer.java
new file mode 100644
index 000000000..e964925af
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalAvoidPlayer.java
@@ -0,0 +1,82 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public class PathfinderGoalAvoidPlayer extends PathfinderGoal {
+
+    public final IEntitySelector a = new EntitySelectorViewable(this);
+    private EntityCreature b;
+    private double c;
+    private double d;
+    private Entity e;
+    private float f;
+    private PathEntity g;
+    private Navigation h;
+    private Class i;
+
+    public PathfinderGoalAvoidPlayer(EntityCreature entitycreature, Class oclass, float f, double d0, double d1) {
+        this.b = entitycreature;
+        this.i = oclass;
+        this.f = f;
+        this.c = d0;
+        this.d = d1;
+        this.h = entitycreature.getNavigation();
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.i == EntityHuman.class) {
+            if (this.b instanceof EntityTameableAnimal && ((EntityTameableAnimal) this.b).isTamed()) {
+                return false;
+            }
+
+            this.e = this.b.world.findNearbyPlayer(this.b, (double) this.f);
+            if (this.e == null) {
+                return false;
+            }
+        } else {
+            List list = this.b.world.a(this.i, this.b.boundingBox.grow((double) this.f, 3.0D, (double) this.f), this.a);
+
+            if (list.isEmpty()) {
+                return false;
+            }
+
+            this.e = (Entity) list.get(0);
+        }
+
+        Vec3D vec3d = RandomPositionGenerator.b(this.b, 16, 7, Vec3D.a(this.e.locX, this.e.locY, this.e.locZ));
+
+        if (vec3d == null) {
+            return false;
+        } else if (this.e.e(vec3d.a, vec3d.b, vec3d.c) < this.e.f((Entity) this.b)) {
+            return false;
+        } else {
+            this.g = this.h.a(vec3d.a, vec3d.b, vec3d.c);
+            return this.g == null ? false : this.g.b(vec3d);
+        }
+    }
+
+    public boolean b() {
+        return !this.h.g();
+    }
+
+    public void c() {
+        this.h.a(this.g, this.c);
+    }
+
+    public void d() {
+        this.e = null;
+    }
+
+    public void e() {
+        if (this.b.f(this.e) < 49.0D) {
+            this.b.getNavigation().a(this.d);
+        } else {
+            this.b.getNavigation().a(this.c);
+        }
+    }
+
+    static EntityCreature a(PathfinderGoalAvoidPlayer pathfindergoalavoidplayer) {
+        return pathfindergoalavoidplayer.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
new file mode 100644
index 000000000..846214a4d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
@@ -0,0 +1,65 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class PathfinderGoalFleeSun extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+    private World f;
+
+    public PathfinderGoalFleeSun(EntityCreature entitycreature, double d0) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.f = entitycreature.world;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (!this.f.w()) {
+            return false;
+        } else if (!this.a.isBurning()) {
+            return false;
+        } else if (!this.f.i(MathHelper.floor(this.a.locX), (int) this.a.boundingBox.b, MathHelper.floor(this.a.locZ))) {
+            return false;
+        } else {
+            Vec3D vec3d = this.f();
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.b = vec3d.a;
+                this.c = vec3d.b;
+                this.d = vec3d.c;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().g();
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+    }
+
+    private Vec3D f() {
+        Random random = this.a.aI();
+
+        for (int i = 0; i < 10; ++i) {
+            int j = MathHelper.floor(this.a.locX + (double) random.nextInt(20) - 10.0D);
+            int k = MathHelper.floor(this.a.boundingBox.b + (double) random.nextInt(6) - 3.0D);
+            int l = MathHelper.floor(this.a.locZ + (double) random.nextInt(20) - 10.0D);
+
+            if (!this.f.i(j, k, l) && this.a.a(j, k, l) < 0.0F) {
+                return Vec3D.a((double) j, (double) k, (double) l);
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalJumpOnBlock.java b/src/main/java/net/minecraft/server/PathfinderGoalJumpOnBlock.java
new file mode 100644
index 000000000..e28f3f20e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalJumpOnBlock.java
@@ -0,0 +1,98 @@
+package net.minecraft.server;
+
+public class PathfinderGoalJumpOnBlock extends PathfinderGoal {
+
+    private final EntityOcelot a;
+    private final double b;
+    private int c;
+    private int d;
+    private int e;
+    private int f;
+    private int g;
+    private int h;
+
+    public PathfinderGoalJumpOnBlock(EntityOcelot entityocelot, double d0) {
+        this.a = entityocelot;
+        this.b = d0;
+        this.a(5);
+    }
+
+    public boolean a() {
+        return this.a.isTamed() && !this.a.isSitting() && this.a.aI().nextDouble() <= 0.006500000134110451D && this.f();
+    }
+
+    public boolean b() {
+        return this.c <= this.e && this.d <= 60 && this.a(this.a.world, this.f, this.g, this.h);
+    }
+
+    public void c() {
+        this.a.getNavigation().a((double) ((float) this.f) + 0.5D, (double) (this.g + 1), (double) ((float) this.h) + 0.5D, this.b);
+        this.c = 0;
+        this.d = 0;
+        this.e = this.a.aI().nextInt(this.a.aI().nextInt(1200) + 1200) + 1200;
+        this.a.getGoalSit().setSitting(false);
+    }
+
+    public void d() {
+        this.a.setSitting(false);
+    }
+
+    public void e() {
+        ++this.c;
+        this.a.getGoalSit().setSitting(false);
+        if (this.a.e((double) this.f, (double) (this.g + 1), (double) this.h) > 1.0D) {
+            this.a.setSitting(false);
+            this.a.getNavigation().a((double) ((float) this.f) + 0.5D, (double) (this.g + 1), (double) ((float) this.h) + 0.5D, this.b);
+            ++this.d;
+        } else if (!this.a.isSitting()) {
+            this.a.setSitting(true);
+        } else {
+            --this.d;
+        }
+    }
+
+    private boolean f() {
+        int i = (int) this.a.locY;
+        double d0 = 2.147483647E9D;
+
+        for (int j = (int) this.a.locX - 8; (double) j < this.a.locX + 8.0D; ++j) {
+            for (int k = (int) this.a.locZ - 8; (double) k < this.a.locZ + 8.0D; ++k) {
+                if (this.a(this.a.world, j, i, k) && this.a.world.isEmpty(j, i + 1, k)) {
+                    double d1 = this.a.e((double) j, (double) i, (double) k);
+
+                    if (d1 < d0) {
+                        this.f = j;
+                        this.g = i;
+                        this.h = k;
+                        d0 = d1;
+                    }
+                }
+            }
+        }
+
+        return d0 < 2.147483647E9D;
+    }
+
+    private boolean a(World world, int i, int j, int k) {
+        Block block = world.getType(i, j, k);
+        int l = world.getData(i, j, k);
+
+        if (block == Blocks.CHEST) {
+            TileEntityChest tileentitychest = (TileEntityChest) world.getTileEntity(i, j, k);
+
+            if (tileentitychest.o < 1) {
+                return true;
+            }
+        } else {
+            if (block == Blocks.BURNING_FURNACE) {
+                return true;
+            }
+
+            if (block == Blocks.BED && !BlockBed.b(l)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
new file mode 100644
index 000000000..06f2765d6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
@@ -0,0 +1,62 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveIndoors extends PathfinderGoal {
+
+    private EntityCreature a;
+    private VillageDoor b;
+    private int c = -1;
+    private int d = -1;
+
+    public PathfinderGoalMoveIndoors(EntityCreature entitycreature) {
+        this.a = entitycreature;
+        this.a(1);
+    }
+
+    public boolean a() {
+        int i = MathHelper.floor(this.a.locX);
+        int j = MathHelper.floor(this.a.locY);
+        int k = MathHelper.floor(this.a.locZ);
+
+        if ((!this.a.world.w() || this.a.world.Q() || !this.a.world.getBiome(i, k).e()) && !this.a.world.worldProvider.g) {
+            if (this.a.aI().nextInt(50) != 0) {
+                return false;
+            } else if (this.c != -1 && this.a.e((double) this.c, this.a.locY, (double) this.d) < 4.0D) {
+                return false;
+            } else {
+                Village village = this.a.world.villages.getClosestVillage(i, j, k, 14);
+
+                if (village == null) {
+                    return false;
+                } else {
+                    this.b = village.c(i, j, k);
+                    return this.b != null;
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().g();
+    }
+
+    public void c() {
+        this.c = -1;
+        if (this.a.e((double) this.b.getIndoorsX(), (double) this.b.locY, (double) this.b.getIndoorsZ()) > 256.0D) {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 14, 3, Vec3D.a((double) this.b.getIndoorsX() + 0.5D, (double) this.b.getIndoorsY(), (double) this.b.getIndoorsZ() + 0.5D));
+
+            if (vec3d != null) {
+                this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, 1.0D);
+            }
+        } else {
+            this.a.getNavigation().a((double) this.b.getIndoorsX() + 0.5D, (double) this.b.getIndoorsY(), (double) this.b.getIndoorsZ() + 0.5D, 1.0D);
+        }
+    }
+
+    public void d() {
+        this.c = this.b.getIndoorsX();
+        this.d = this.b.getIndoorsZ();
+        this.b = null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
new file mode 100644
index 000000000..f4ec2d44d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
@@ -0,0 +1,121 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class PathfinderGoalMoveThroughVillage extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private PathEntity c;
+    private VillageDoor d;
+    private boolean e;
+    private List f = new ArrayList();
+
+    public PathfinderGoalMoveThroughVillage(EntityCreature entitycreature, double d0, boolean flag) {
+        this.a = entitycreature;
+        this.b = d0;
+        this.e = flag;
+        this.a(1);
+    }
+
+    public boolean a() {
+        this.f();
+        if (this.e && this.a.world.w()) {
+            return false;
+        } else {
+            Village village = this.a.world.villages.getClosestVillage(MathHelper.floor(this.a.locX), MathHelper.floor(this.a.locY), MathHelper.floor(this.a.locZ), 0);
+
+            if (village == null) {
+                return false;
+            } else {
+                this.d = this.a(village);
+                if (this.d == null) {
+                    return false;
+                } else {
+                    boolean flag = this.a.getNavigation().c();
+
+                    this.a.getNavigation().b(false);
+                    this.c = this.a.getNavigation().a((double) this.d.locX, (double) this.d.locY, (double) this.d.locZ);
+                    this.a.getNavigation().b(flag);
+                    if (this.c != null) {
+                        return true;
+                    } else {
+                        Vec3D vec3d = RandomPositionGenerator.a(this.a, 10, 7, Vec3D.a((double) this.d.locX, (double) this.d.locY, (double) this.d.locZ));
+
+                        if (vec3d == null) {
+                            return false;
+                        } else {
+                            this.a.getNavigation().b(false);
+                            this.c = this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c);
+                            this.a.getNavigation().b(flag);
+                            return this.c != null;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public boolean b() {
+        if (this.a.getNavigation().g()) {
+            return false;
+        } else {
+            float f = this.a.width + 4.0F;
+
+            return this.a.e((double) this.d.locX, (double) this.d.locY, (double) this.d.locZ) > (double) (f * f);
+        }
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.c, this.b);
+    }
+
+    public void d() {
+        if (this.a.getNavigation().g() || this.a.e((double) this.d.locX, (double) this.d.locY, (double) this.d.locZ) < 16.0D) {
+            this.f.add(this.d);
+        }
+    }
+
+    private VillageDoor a(Village village) {
+        VillageDoor villagedoor = null;
+        int i = Integer.MAX_VALUE;
+        List list = village.getDoors();
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            VillageDoor villagedoor1 = (VillageDoor) iterator.next();
+            int j = villagedoor1.b(MathHelper.floor(this.a.locX), MathHelper.floor(this.a.locY), MathHelper.floor(this.a.locZ));
+
+            if (j < i && !this.a(villagedoor1)) {
+                villagedoor = villagedoor1;
+                i = j;
+            }
+        }
+
+        return villagedoor;
+    }
+
+    private boolean a(VillageDoor villagedoor) {
+        Iterator iterator = this.f.iterator();
+
+        VillageDoor villagedoor1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            villagedoor1 = (VillageDoor) iterator.next();
+        } while (villagedoor.locX != villagedoor1.locX || villagedoor.locY != villagedoor1.locY || villagedoor.locZ != villagedoor1.locZ);
+
+        return true;
+    }
+
+    private void f() {
+        if (this.f.size() > 15) {
+            this.f.remove(0);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
new file mode 100644
index 000000000..69a940e5d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveTowardsRestriction extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+
+    public PathfinderGoalMoveTowardsRestriction(EntityCreature entitycreature, double d0) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.a.bU()) {
+            return false;
+        } else {
+            ChunkCoordinates chunkcoordinates = this.a.bV();
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 7, Vec3D.a((double) chunkcoordinates.x, (double) chunkcoordinates.y, (double) chunkcoordinates.z));
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.b = vec3d.a;
+                this.c = vec3d.b;
+                this.d = vec3d.c;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().g();
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
new file mode 100644
index 000000000..28c6252c8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveTowardsTarget extends PathfinderGoal {
+
+    private EntityCreature a;
+    private EntityLiving b;
+    private double c;
+    private double d;
+    private double e;
+    private double f;
+    private float g;
+
+    public PathfinderGoalMoveTowardsTarget(EntityCreature entitycreature, double d0, float f) {
+        this.a = entitycreature;
+        this.f = d0;
+        this.g = f;
+        this.a(1);
+    }
+
+    public boolean a() {
+        this.b = this.a.getGoalTarget();
+        if (this.b == null) {
+            return false;
+        } else if (this.b.f(this.a) > (double) (this.g * this.g)) {
+            return false;
+        } else {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 7, Vec3D.a(this.b.locX, this.b.locY, this.b.locZ));
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.c = vec3d.a;
+                this.d = vec3d.b;
+                this.e = vec3d.c;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().g() && this.b.isAlive() && this.b.f(this.a) < (double) (this.g * this.g);
+    }
+
+    public void d() {
+        this.b = null;
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.c, this.d, this.e, this.f);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalPlay.java b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
new file mode 100644
index 000000000..8fba19a7f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
@@ -0,0 +1,87 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class PathfinderGoalPlay extends PathfinderGoal {
+
+    private EntityVillager a;
+    private EntityLiving b;
+    private double c;
+    private int d;
+
+    public PathfinderGoalPlay(EntityVillager entityvillager, double d0) {
+        this.a = entityvillager;
+        this.c = d0;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.a.getAge() >= 0) {
+            return false;
+        } else if (this.a.aI().nextInt(400) != 0) {
+            return false;
+        } else {
+            List list = this.a.world.a(EntityVillager.class, this.a.boundingBox.grow(6.0D, 3.0D, 6.0D));
+            double d0 = Double.MAX_VALUE;
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EntityVillager entityvillager = (EntityVillager) iterator.next();
+
+                if (entityvillager != this.a && !entityvillager.cb() && entityvillager.getAge() < 0) {
+                    double d1 = entityvillager.f(this.a);
+
+                    if (d1 <= d0) {
+                        d0 = d1;
+                        this.b = entityvillager;
+                    }
+                }
+            }
+
+            if (this.b == null) {
+                Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 3);
+
+                if (vec3d == null) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public boolean b() {
+        return this.d > 0;
+    }
+
+    public void c() {
+        if (this.b != null) {
+            this.a.j(true);
+        }
+
+        this.d = 1000;
+    }
+
+    public void d() {
+        this.a.j(false);
+        this.b = null;
+    }
+
+    public void e() {
+        --this.d;
+        if (this.b != null) {
+            if (this.a.f(this.b) > 4.0D) {
+                this.a.getNavigation().a((Entity) this.b, this.c);
+            }
+        } else if (this.a.getNavigation().g()) {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 3);
+
+            if (vec3d == null) {
+                return;
+            }
+
+            this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, this.c);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
new file mode 100644
index 000000000..396997afe
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
@@ -0,0 +1,43 @@
+package net.minecraft.server;
+
+public class PathfinderGoalRandomStroll extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+
+    public PathfinderGoalRandomStroll(EntityCreature entitycreature, double d0) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.a.aN() >= 100) {
+            return false;
+        } else if (this.a.aI().nextInt(120) != 0) {
+            return false;
+        } else {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 10, 7);
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.b = vec3d.a;
+                this.c = vec3d.b;
+                this.d = vec3d.c;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().g();
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/QueuedProtocolSwitch.java b/src/main/java/net/minecraft/server/QueuedProtocolSwitch.java
new file mode 100644
index 000000000..344e4f00b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/QueuedProtocolSwitch.java
@@ -0,0 +1,29 @@
+package net.minecraft.server;
+
+import net.minecraft.util.io.netty.channel.ChannelFutureListener;
+import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
+
+class QueuedProtocolSwitch implements Runnable {
+
+    final EnumProtocol a;
+    final EnumProtocol b;
+    final Packet c;
+    final GenericFutureListener[] d;
+    final NetworkManager e;
+
+    QueuedProtocolSwitch(NetworkManager networkmanager, EnumProtocol enumprotocol, EnumProtocol enumprotocol1, Packet packet, GenericFutureListener[] agenericfuturelistener) {
+        this.e = networkmanager;
+        this.a = enumprotocol;
+        this.b = enumprotocol1;
+        this.c = packet;
+        this.d = agenericfuturelistener;
+    }
+
+    public void run() {
+        if (this.a != this.b) {
+            this.e.a(this.a);
+        }
+
+        NetworkManager.a(this.e).writeAndFlush(this.c).addListeners(this.d).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RandomPositionGenerator.java b/src/main/java/net/minecraft/server/RandomPositionGenerator.java
new file mode 100644
index 000000000..9342a3f42
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RandomPositionGenerator.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class RandomPositionGenerator {
+
+    private static Vec3D a = Vec3D.a(0.0D, 0.0D, 0.0D);
+
+    public static Vec3D a(EntityCreature entitycreature, int i, int j) {
+        return c(entitycreature, i, j, (Vec3D) null);
+    }
+
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        a.a = vec3d.a - entitycreature.locX;
+        a.b = vec3d.b - entitycreature.locY;
+        a.c = vec3d.c - entitycreature.locZ;
+        return c(entitycreature, i, j, a);
+    }
+
+    public static Vec3D b(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        a.a = entitycreature.locX - vec3d.a;
+        a.b = entitycreature.locY - vec3d.b;
+        a.c = entitycreature.locZ - vec3d.c;
+        return c(entitycreature, i, j, a);
+    }
+
+    private static Vec3D c(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Random random = entitycreature.aI();
+        boolean flag = false;
+        int k = 0;
+        int l = 0;
+        int i1 = 0;
+        float f = -99999.0F;
+        boolean flag1;
+
+        if (entitycreature.bY()) {
+            double d0 = (double) (entitycreature.bV().e(MathHelper.floor(entitycreature.locX), MathHelper.floor(entitycreature.locY), MathHelper.floor(entitycreature.locZ)) + 4.0F);
+            double d1 = (double) (entitycreature.bW() + (float) i);
+
+            flag1 = d0 < d1 * d1;
+        } else {
+            flag1 = false;
+        }
+
+        for (int j1 = 0; j1 < 10; ++j1) {
+            int k1 = random.nextInt(2 * i) - i;
+            int l1 = random.nextInt(2 * j) - j;
+            int i2 = random.nextInt(2 * i) - i;
+
+            if (vec3d == null || (double) k1 * vec3d.a + (double) i2 * vec3d.c >= 0.0D) {
+                k1 += MathHelper.floor(entitycreature.locX);
+                l1 += MathHelper.floor(entitycreature.locY);
+                i2 += MathHelper.floor(entitycreature.locZ);
+                if (!flag1 || entitycreature.b(k1, l1, i2)) {
+                    float f1 = entitycreature.a(k1, l1, i2);
+
+                    if (f1 > f) {
+                        f = f1;
+                        k = k1;
+                        l = l1;
+                        i1 = i2;
+                        flag = true;
+                    }
+                }
+            }
+        }
+
+        if (flag) {
+            return Vec3D.a((double) k, (double) l, (double) i1);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegistryBlocks.java b/src/main/java/net/minecraft/server/RegistryBlocks.java
new file mode 100644
index 000000000..43f926919
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegistryBlocks.java
@@ -0,0 +1,35 @@
+package net.minecraft.server;
+
+public class RegistryBlocks extends RegistryMaterials {
+
+    private final String d;
+    private Object e;
+
+    public RegistryBlocks(String s) {
+        this.d = s;
+    }
+
+    public void a(int i, String s, Object object) {
+        if (this.d.equals(s)) {
+            this.e = object;
+        }
+
+        super.a(i, s, object);
+    }
+
+    public Object get(String s) {
+        Object object = super.get(s);
+
+        return object == null ? this.e : object;
+    }
+
+    public Object a(int i) {
+        Object object = super.a(i);
+
+        return object == null ? this.e : object;
+    }
+
+    public Object get(Object object) {
+        return this.get((String) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Scoreboard.java b/src/main/java/net/minecraft/server/Scoreboard.java
new file mode 100644
index 000000000..d3511ca08
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Scoreboard.java
@@ -0,0 +1,275 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class Scoreboard {
+
+    private final Map objectivesByName = new HashMap();
+    private final Map objectivesByCriteria = new HashMap();
+    private final Map playerScores = new HashMap();
+    private final ScoreboardObjective[] displaySlots = new ScoreboardObjective[3];
+    private final Map teamsByName = new HashMap();
+    private final Map teamsByPlayer = new HashMap();
+
+    public Scoreboard() {}
+
+    public ScoreboardObjective getObjective(String s) {
+        return (ScoreboardObjective) this.objectivesByName.get(s);
+    }
+
+    public ScoreboardObjective registerObjective(String s, IScoreboardCriteria iscoreboardcriteria) {
+        ScoreboardObjective scoreboardobjective = this.getObjective(s);
+
+        if (scoreboardobjective != null) {
+            throw new IllegalArgumentException("An objective with the name \'" + s + "\' already exists!");
+        } else {
+            scoreboardobjective = new ScoreboardObjective(this, s, iscoreboardcriteria);
+            Object object = (List) this.objectivesByCriteria.get(iscoreboardcriteria);
+
+            if (object == null) {
+                object = new ArrayList();
+                this.objectivesByCriteria.put(iscoreboardcriteria, object);
+            }
+
+            ((List) object).add(scoreboardobjective);
+            this.objectivesByName.put(s, scoreboardobjective);
+            this.handleObjectiveAdded(scoreboardobjective);
+            return scoreboardobjective;
+        }
+    }
+
+    public Collection getObjectivesForCriteria(IScoreboardCriteria iscoreboardcriteria) {
+        Collection collection = (Collection) this.objectivesByCriteria.get(iscoreboardcriteria);
+
+        return collection == null ? new ArrayList() : new ArrayList(collection);
+    }
+
+    public ScoreboardScore getPlayerScoreForObjective(String s, ScoreboardObjective scoreboardobjective) {
+        Object object = (Map) this.playerScores.get(s);
+
+        if (object == null) {
+            object = new HashMap();
+            this.playerScores.put(s, object);
+        }
+
+        ScoreboardScore scoreboardscore = (ScoreboardScore) ((Map) object).get(scoreboardobjective);
+
+        if (scoreboardscore == null) {
+            scoreboardscore = new ScoreboardScore(this, scoreboardobjective, s);
+            ((Map) object).put(scoreboardobjective, scoreboardscore);
+        }
+
+        return scoreboardscore;
+    }
+
+    public Collection getScoresForObjective(ScoreboardObjective scoreboardobjective) {
+        ArrayList arraylist = new ArrayList();
+        Iterator iterator = this.playerScores.values().iterator();
+
+        while (iterator.hasNext()) {
+            Map map = (Map) iterator.next();
+            ScoreboardScore scoreboardscore = (ScoreboardScore) map.get(scoreboardobjective);
+
+            if (scoreboardscore != null) {
+                arraylist.add(scoreboardscore);
+            }
+        }
+
+        Collections.sort(arraylist, ScoreboardScore.a);
+        return arraylist;
+    }
+
+    public Collection getObjectives() {
+        return this.objectivesByName.values();
+    }
+
+    public Collection getPlayers() {
+        return this.playerScores.keySet();
+    }
+
+    public void resetPlayerScores(String s) {
+        Map map = (Map) this.playerScores.remove(s);
+
+        if (map != null) {
+            this.handlePlayerRemoved(s);
+        }
+    }
+
+    public Collection getScores() {
+        Collection collection = this.playerScores.values();
+        ArrayList arraylist = new ArrayList();
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            Map map = (Map) iterator.next();
+
+            arraylist.addAll(map.values());
+        }
+
+        return arraylist;
+    }
+
+    public Map getPlayerObjectives(String s) {
+        Object object = (Map) this.playerScores.get(s);
+
+        if (object == null) {
+            object = new HashMap();
+        }
+
+        return (Map) object;
+    }
+
+    public void unregisterObjective(ScoreboardObjective scoreboardobjective) {
+        this.objectivesByName.remove(scoreboardobjective.getName());
+
+        for (int i = 0; i < 3; ++i) {
+            if (this.getObjectiveForSlot(i) == scoreboardobjective) {
+                this.setDisplaySlot(i, (ScoreboardObjective) null);
+            }
+        }
+
+        List list = (List) this.objectivesByCriteria.get(scoreboardobjective.getCriteria());
+
+        if (list != null) {
+            list.remove(scoreboardobjective);
+        }
+
+        Iterator iterator = this.playerScores.values().iterator();
+
+        while (iterator.hasNext()) {
+            Map map = (Map) iterator.next();
+
+            map.remove(scoreboardobjective);
+        }
+
+        this.handleObjectiveRemoved(scoreboardobjective);
+    }
+
+    public void setDisplaySlot(int i, ScoreboardObjective scoreboardobjective) {
+        this.displaySlots[i] = scoreboardobjective;
+    }
+
+    public ScoreboardObjective getObjectiveForSlot(int i) {
+        return this.displaySlots[i];
+    }
+
+    public ScoreboardTeam getTeam(String s) {
+        return (ScoreboardTeam) this.teamsByName.get(s);
+    }
+
+    public ScoreboardTeam createTeam(String s) {
+        ScoreboardTeam scoreboardteam = this.getTeam(s);
+
+        if (scoreboardteam != null) {
+            throw new IllegalArgumentException("A team with the name \'" + s + "\' already exists!");
+        } else {
+            scoreboardteam = new ScoreboardTeam(this, s);
+            this.teamsByName.put(s, scoreboardteam);
+            this.handleTeamAdded(scoreboardteam);
+            return scoreboardteam;
+        }
+    }
+
+    public void removeTeam(ScoreboardTeam scoreboardteam) {
+        this.teamsByName.remove(scoreboardteam.getName());
+        Iterator iterator = scoreboardteam.getPlayerNameSet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            this.teamsByPlayer.remove(s);
+        }
+
+        this.handleTeamRemoved(scoreboardteam);
+    }
+
+    public boolean addPlayerToTeam(String s, String s1) {
+        if (!this.teamsByName.containsKey(s1)) {
+            return false;
+        } else {
+            ScoreboardTeam scoreboardteam = this.getTeam(s1);
+
+            if (this.getPlayerTeam(s) != null) {
+                this.removePlayerFromTeam(s);
+            }
+
+            this.teamsByPlayer.put(s, scoreboardteam);
+            scoreboardteam.getPlayerNameSet().add(s);
+            return true;
+        }
+    }
+
+    public boolean removePlayerFromTeam(String s) {
+        ScoreboardTeam scoreboardteam = this.getPlayerTeam(s);
+
+        if (scoreboardteam != null) {
+            this.removePlayerFromTeam(s, scoreboardteam);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void removePlayerFromTeam(String s, ScoreboardTeam scoreboardteam) {
+        if (this.getPlayerTeam(s) != scoreboardteam) {
+            throw new IllegalStateException("Player is either on another team or not on any team. Cannot remove from team \'" + scoreboardteam.getName() + "\'.");
+        } else {
+            this.teamsByPlayer.remove(s);
+            scoreboardteam.getPlayerNameSet().remove(s);
+        }
+    }
+
+    public Collection getTeamNames() {
+        return this.teamsByName.keySet();
+    }
+
+    public Collection getTeams() {
+        return this.teamsByName.values();
+    }
+
+    public ScoreboardTeam getPlayerTeam(String s) {
+        return (ScoreboardTeam) this.teamsByPlayer.get(s);
+    }
+
+    public void handleObjectiveAdded(ScoreboardObjective scoreboardobjective) {}
+
+    public void handleObjectiveChanged(ScoreboardObjective scoreboardobjective) {}
+
+    public void handleObjectiveRemoved(ScoreboardObjective scoreboardobjective) {}
+
+    public void handleScoreChanged(ScoreboardScore scoreboardscore) {}
+
+    public void handlePlayerRemoved(String s) {}
+
+    public void handleTeamAdded(ScoreboardTeam scoreboardteam) {}
+
+    public void handleTeamChanged(ScoreboardTeam scoreboardteam) {}
+
+    public void handleTeamRemoved(ScoreboardTeam scoreboardteam) {}
+
+    public static String getSlotName(int i) {
+        switch (i) {
+        case 0:
+            return "list";
+
+        case 1:
+            return "sidebar";
+
+        case 2:
+            return "belowName";
+
+        default:
+            return null;
+        }
+    }
+
+    public static int getSlotForName(String s) {
+        return s.equalsIgnoreCase("list") ? 0 : (s.equalsIgnoreCase("sidebar") ? 1 : (s.equalsIgnoreCase("belowName") ? 2 : -1));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 000000000..b205ab70d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity {
+
+    public float a;
+    public float i;
+    public int j;
+    private int k;
+
+    public TileEntityEnderChest() {}
+
+    public void h() {
+        super.h();
+        if (++this.k % 20 * 4 == 0) {
+            this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+        }
+
+        this.i = this.a;
+        float f = 0.1F;
+        double d0;
+
+        if (this.j > 0 && this.a == 0.0F) {
+            double d1 = (double) this.x + 0.5D;
+
+            d0 = (double) this.z + 0.5D;
+            this.world.makeSound(d1, (double) this.y + 0.5D, d0, "random.chestopen", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.j == 0 && this.a > 0.0F || this.j > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.j > 0) {
+                this.a += f;
+            } else {
+                this.a -= f;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < f2 && f1 >= f2) {
+                d0 = (double) this.x + 0.5D;
+                double d2 = (double) this.z + 0.5D;
+
+                this.world.makeSound(d0, (double) this.y + 0.5D, d2, "random.chestclosed", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.j = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void s() {
+        this.u();
+        super.s();
+    }
+
+    public void a() {
+        ++this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public void b() {
+        --this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.x, this.y, this.z) != this ? false : entityhuman.e((double) this.x + 0.5D, (double) this.y + 0.5D, (double) this.z + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityLightDetector.java b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
new file mode 100644
index 000000000..143cffbab
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
@@ -0,0 +1,15 @@
+package net.minecraft.server;
+
+public class TileEntityLightDetector extends TileEntity {
+
+    public TileEntityLightDetector() {}
+
+    public void h() {
+        if (this.world != null && !this.world.isStatic && this.world.getTime() % 20L == 0L) {
+            this.h = this.q();
+            if (this.h instanceof BlockDaylightDetector) {
+                ((BlockDaylightDetector) this.h).e(this.world, this.x, this.y, this.z);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldChunkManager.java b/src/main/java/net/minecraft/server/WorldChunkManager.java
new file mode 100644
index 000000000..4b94d1cf6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldChunkManager.java
@@ -0,0 +1,195 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+public class WorldChunkManager {
+
+    private GenLayer c;
+    private GenLayer d;
+    private BiomeCache e;
+    private List f;
+
+    protected WorldChunkManager() {
+        this.e = new BiomeCache(this);
+        this.f = new ArrayList();
+        this.f.add(BiomeBase.FOREST);
+        this.f.add(BiomeBase.PLAINS);
+        this.f.add(BiomeBase.TAIGA);
+        this.f.add(BiomeBase.TAIGA_HILLS);
+        this.f.add(BiomeBase.FOREST_HILLS);
+        this.f.add(BiomeBase.JUNGLE);
+        this.f.add(BiomeBase.JUNGLE_HILLS);
+    }
+
+    public WorldChunkManager(long i, WorldType worldtype) {
+        this();
+        GenLayer[] agenlayer = GenLayer.a(i, worldtype);
+
+        this.c = agenlayer[0];
+        this.d = agenlayer[1];
+    }
+
+    public WorldChunkManager(World world) {
+        this(world.getSeed(), world.getWorldData().getType());
+    }
+
+    public List a() {
+        return this.f;
+    }
+
+    public BiomeBase getBiome(int i, int j) {
+        return this.e.b(i, j);
+    }
+
+    public float[] getWetness(float[] afloat, int i, int j, int k, int l) {
+        IntCache.a();
+        if (afloat == null || afloat.length < k * l) {
+            afloat = new float[k * l];
+        }
+
+        int[] aint = this.d.a(i, j, k, l);
+
+        for (int i1 = 0; i1 < k * l; ++i1) {
+            try {
+                float f = (float) BiomeBase.getBiome(aint[i1]).h() / 65536.0F;
+
+                if (f > 1.0F) {
+                    f = 1.0F;
+                }
+
+                afloat[i1] = f;
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("DownfallBlock");
+
+                crashreportsystemdetails.a("biome id", Integer.valueOf(i1));
+                crashreportsystemdetails.a("downfalls[] size", Integer.valueOf(afloat.length));
+                crashreportsystemdetails.a("x", Integer.valueOf(i));
+                crashreportsystemdetails.a("z", Integer.valueOf(j));
+                crashreportsystemdetails.a("w", Integer.valueOf(k));
+                crashreportsystemdetails.a("h", Integer.valueOf(l));
+                throw new ReportedException(crashreport);
+            }
+        }
+
+        return afloat;
+    }
+
+    public BiomeBase[] getBiomes(BiomeBase[] abiomebase, int i, int j, int k, int l) {
+        IntCache.a();
+        if (abiomebase == null || abiomebase.length < k * l) {
+            abiomebase = new BiomeBase[k * l];
+        }
+
+        int[] aint = this.c.a(i, j, k, l);
+
+        try {
+            for (int i1 = 0; i1 < k * l; ++i1) {
+                abiomebase[i1] = BiomeBase.getBiome(aint[i1]);
+            }
+
+            return abiomebase;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("RawBiomeBlock");
+
+            crashreportsystemdetails.a("biomes[] size", Integer.valueOf(abiomebase.length));
+            crashreportsystemdetails.a("x", Integer.valueOf(i));
+            crashreportsystemdetails.a("z", Integer.valueOf(j));
+            crashreportsystemdetails.a("w", Integer.valueOf(k));
+            crashreportsystemdetails.a("h", Integer.valueOf(l));
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public BiomeBase[] getBiomeBlock(BiomeBase[] abiomebase, int i, int j, int k, int l) {
+        return this.a(abiomebase, i, j, k, l, true);
+    }
+
+    public BiomeBase[] a(BiomeBase[] abiomebase, int i, int j, int k, int l, boolean flag) {
+        IntCache.a();
+        if (abiomebase == null || abiomebase.length < k * l) {
+            abiomebase = new BiomeBase[k * l];
+        }
+
+        if (flag && k == 16 && l == 16 && (i & 15) == 0 && (j & 15) == 0) {
+            BiomeBase[] abiomebase1 = this.e.d(i, j);
+
+            System.arraycopy(abiomebase1, 0, abiomebase, 0, k * l);
+            return abiomebase;
+        } else {
+            int[] aint = this.d.a(i, j, k, l);
+
+            for (int i1 = 0; i1 < k * l; ++i1) {
+                abiomebase[i1] = BiomeBase.getBiome(aint[i1]);
+            }
+
+            return abiomebase;
+        }
+    }
+
+    public boolean a(int i, int j, int k, List list) {
+        IntCache.a();
+        int l = i - k >> 2;
+        int i1 = j - k >> 2;
+        int j1 = i + k >> 2;
+        int k1 = j + k >> 2;
+        int l1 = j1 - l + 1;
+        int i2 = k1 - i1 + 1;
+        int[] aint = this.c.a(l, i1, l1, i2);
+
+        try {
+            for (int j2 = 0; j2 < l1 * i2; ++j2) {
+                BiomeBase biomebase = BiomeBase.getBiome(aint[j2]);
+
+                if (!list.contains(biomebase)) {
+                    return false;
+                }
+            }
+
+            return true;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Layer");
+
+            crashreportsystemdetails.a("Layer", this.c.toString());
+            crashreportsystemdetails.a("x", Integer.valueOf(i));
+            crashreportsystemdetails.a("z", Integer.valueOf(j));
+            crashreportsystemdetails.a("radius", Integer.valueOf(k));
+            crashreportsystemdetails.a("allowed", list);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public ChunkPosition a(int i, int j, int k, List list, Random random) {
+        IntCache.a();
+        int l = i - k >> 2;
+        int i1 = j - k >> 2;
+        int j1 = i + k >> 2;
+        int k1 = j + k >> 2;
+        int l1 = j1 - l + 1;
+        int i2 = k1 - i1 + 1;
+        int[] aint = this.c.a(l, i1, l1, i2);
+        ChunkPosition chunkposition = null;
+        int j2 = 0;
+
+        for (int k2 = 0; k2 < l1 * i2; ++k2) {
+            int l2 = l + k2 % l1 << 2;
+            int i3 = i1 + k2 / l1 << 2;
+            BiomeBase biomebase = BiomeBase.getBiome(aint[k2]);
+
+            if (list.contains(biomebase) && (chunkposition == null || random.nextInt(j2 + 1) == 0)) {
+                chunkposition = new ChunkPosition(l2, 0, i3);
+                ++j2;
+            }
+        }
+
+        return chunkposition;
+    }
+
+    public void b() {
+        this.e.a();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldData.java b/src/main/java/net/minecraft/server/WorldData.java
new file mode 100644
index 000000000..3036d3d31
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldData.java
@@ -0,0 +1,417 @@
+package net.minecraft.server;
+
+import java.util.concurrent.Callable;
+
+public class WorldData {
+
+    private long seed;
+    private WorldType type;
+    private String generatorOptions;
+    private int spawnX;
+    private int spawnY;
+    private int spawnZ;
+    private long time;
+    private long dayTime;
+    private long lastPlayed;
+    private long sizeOnDisk;
+    private NBTTagCompound playerData;
+    private int dimension;
+    private String name;
+    private int version;
+    private boolean isRaining;
+    private int rainTicks;
+    private boolean isThundering;
+    private int thunderTicks;
+    private EnumGamemode gameType;
+    private boolean useMapFeatures;
+    private boolean hardcore;
+    private boolean allowCommands;
+    private boolean initialized;
+    private GameRules gameRules;
+
+    protected WorldData() {
+        this.type = WorldType.NORMAL;
+        this.generatorOptions = "";
+        this.gameRules = new GameRules();
+    }
+
+    public WorldData(NBTTagCompound nbttagcompound) {
+        this.type = WorldType.NORMAL;
+        this.generatorOptions = "";
+        this.gameRules = new GameRules();
+        this.seed = nbttagcompound.getLong("RandomSeed");
+        if (nbttagcompound.hasKeyOfType("generatorName", 8)) {
+            String s = nbttagcompound.getString("generatorName");
+
+            this.type = WorldType.getType(s);
+            if (this.type == null) {
+                this.type = WorldType.NORMAL;
+            } else if (this.type.f()) {
+                int i = 0;
+
+                if (nbttagcompound.hasKeyOfType("generatorVersion", 99)) {
+                    i = nbttagcompound.getInt("generatorVersion");
+                }
+
+                this.type = this.type.a(i);
+            }
+
+            if (nbttagcompound.hasKeyOfType("generatorOptions", 8)) {
+                this.generatorOptions = nbttagcompound.getString("generatorOptions");
+            }
+        }
+
+        this.gameType = EnumGamemode.getById(nbttagcompound.getInt("GameType"));
+        if (nbttagcompound.hasKeyOfType("MapFeatures", 99)) {
+            this.useMapFeatures = nbttagcompound.getBoolean("MapFeatures");
+        } else {
+            this.useMapFeatures = true;
+        }
+
+        this.spawnX = nbttagcompound.getInt("SpawnX");
+        this.spawnY = nbttagcompound.getInt("SpawnY");
+        this.spawnZ = nbttagcompound.getInt("SpawnZ");
+        this.time = nbttagcompound.getLong("Time");
+        if (nbttagcompound.hasKeyOfType("DayTime", 99)) {
+            this.dayTime = nbttagcompound.getLong("DayTime");
+        } else {
+            this.dayTime = this.time;
+        }
+
+        this.lastPlayed = nbttagcompound.getLong("LastPlayed");
+        this.sizeOnDisk = nbttagcompound.getLong("SizeOnDisk");
+        this.name = nbttagcompound.getString("LevelName");
+        this.version = nbttagcompound.getInt("version");
+        this.rainTicks = nbttagcompound.getInt("rainTime");
+        this.isRaining = nbttagcompound.getBoolean("raining");
+        this.thunderTicks = nbttagcompound.getInt("thunderTime");
+        this.isThundering = nbttagcompound.getBoolean("thundering");
+        this.hardcore = nbttagcompound.getBoolean("hardcore");
+        if (nbttagcompound.hasKeyOfType("initialized", 99)) {
+            this.initialized = nbttagcompound.getBoolean("initialized");
+        } else {
+            this.initialized = true;
+        }
+
+        if (nbttagcompound.hasKeyOfType("allowCommands", 99)) {
+            this.allowCommands = nbttagcompound.getBoolean("allowCommands");
+        } else {
+            this.allowCommands = this.gameType == EnumGamemode.CREATIVE;
+        }
+
+        if (nbttagcompound.hasKeyOfType("Player", 10)) {
+            this.playerData = nbttagcompound.getCompound("Player");
+            this.dimension = this.playerData.getInt("Dimension");
+        }
+
+        if (nbttagcompound.hasKeyOfType("GameRules", 10)) {
+            this.gameRules.a(nbttagcompound.getCompound("GameRules"));
+        }
+    }
+
+    public WorldData(WorldSettings worldsettings, String s) {
+        this.type = WorldType.NORMAL;
+        this.generatorOptions = "";
+        this.gameRules = new GameRules();
+        this.seed = worldsettings.d();
+        this.gameType = worldsettings.e();
+        this.useMapFeatures = worldsettings.g();
+        this.name = s;
+        this.hardcore = worldsettings.f();
+        this.type = worldsettings.h();
+        this.generatorOptions = worldsettings.j();
+        this.allowCommands = worldsettings.i();
+        this.initialized = false;
+    }
+
+    public WorldData(WorldData worlddata) {
+        this.type = WorldType.NORMAL;
+        this.generatorOptions = "";
+        this.gameRules = new GameRules();
+        this.seed = worlddata.seed;
+        this.type = worlddata.type;
+        this.generatorOptions = worlddata.generatorOptions;
+        this.gameType = worlddata.gameType;
+        this.useMapFeatures = worlddata.useMapFeatures;
+        this.spawnX = worlddata.spawnX;
+        this.spawnY = worlddata.spawnY;
+        this.spawnZ = worlddata.spawnZ;
+        this.time = worlddata.time;
+        this.dayTime = worlddata.dayTime;
+        this.lastPlayed = worlddata.lastPlayed;
+        this.sizeOnDisk = worlddata.sizeOnDisk;
+        this.playerData = worlddata.playerData;
+        this.dimension = worlddata.dimension;
+        this.name = worlddata.name;
+        this.version = worlddata.version;
+        this.rainTicks = worlddata.rainTicks;
+        this.isRaining = worlddata.isRaining;
+        this.thunderTicks = worlddata.thunderTicks;
+        this.isThundering = worlddata.isThundering;
+        this.hardcore = worlddata.hardcore;
+        this.allowCommands = worlddata.allowCommands;
+        this.initialized = worlddata.initialized;
+        this.gameRules = worlddata.gameRules;
+    }
+
+    public NBTTagCompound a() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        this.a(nbttagcompound, this.playerData);
+        return nbttagcompound;
+    }
+
+    public NBTTagCompound a(NBTTagCompound nbttagcompound) {
+        NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+        this.a(nbttagcompound1, nbttagcompound);
+        return nbttagcompound1;
+    }
+
+    private void a(NBTTagCompound nbttagcompound, NBTTagCompound nbttagcompound1) {
+        nbttagcompound.setLong("RandomSeed", this.seed);
+        nbttagcompound.setString("generatorName", this.type.name());
+        nbttagcompound.setInt("generatorVersion", this.type.getVersion());
+        nbttagcompound.setString("generatorOptions", this.generatorOptions);
+        nbttagcompound.setInt("GameType", this.gameType.getId());
+        nbttagcompound.setBoolean("MapFeatures", this.useMapFeatures);
+        nbttagcompound.setInt("SpawnX", this.spawnX);
+        nbttagcompound.setInt("SpawnY", this.spawnY);
+        nbttagcompound.setInt("SpawnZ", this.spawnZ);
+        nbttagcompound.setLong("Time", this.time);
+        nbttagcompound.setLong("DayTime", this.dayTime);
+        nbttagcompound.setLong("SizeOnDisk", this.sizeOnDisk);
+        nbttagcompound.setLong("LastPlayed", MinecraftServer.ar());
+        nbttagcompound.setString("LevelName", this.name);
+        nbttagcompound.setInt("version", this.version);
+        nbttagcompound.setInt("rainTime", this.rainTicks);
+        nbttagcompound.setBoolean("raining", this.isRaining);
+        nbttagcompound.setInt("thunderTime", this.thunderTicks);
+        nbttagcompound.setBoolean("thundering", this.isThundering);
+        nbttagcompound.setBoolean("hardcore", this.hardcore);
+        nbttagcompound.setBoolean("allowCommands", this.allowCommands);
+        nbttagcompound.setBoolean("initialized", this.initialized);
+        nbttagcompound.set("GameRules", this.gameRules.a());
+        if (nbttagcompound1 != null) {
+            nbttagcompound.set("Player", nbttagcompound1);
+        }
+    }
+
+    public long getSeed() {
+        return this.seed;
+    }
+
+    public int c() {
+        return this.spawnX;
+    }
+
+    public int d() {
+        return this.spawnY;
+    }
+
+    public int e() {
+        return this.spawnZ;
+    }
+
+    public long getTime() {
+        return this.time;
+    }
+
+    public long getDayTime() {
+        return this.dayTime;
+    }
+
+    public NBTTagCompound i() {
+        return this.playerData;
+    }
+
+    public int j() {
+        return this.dimension;
+    }
+
+    public void setTime(long i) {
+        this.time = i;
+    }
+
+    public void setDayTime(long i) {
+        this.dayTime = i;
+    }
+
+    public void setSpawn(int i, int j, int k) {
+        this.spawnX = i;
+        this.spawnY = j;
+        this.spawnZ = k;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public void setName(String s) {
+        this.name = s;
+    }
+
+    public int l() {
+        return this.version;
+    }
+
+    public void e(int i) {
+        this.version = i;
+    }
+
+    public boolean isThundering() {
+        return this.isThundering;
+    }
+
+    public void setThundering(boolean flag) {
+        this.isThundering = flag;
+    }
+
+    public int getThunderDuration() {
+        return this.thunderTicks;
+    }
+
+    public void setThunderDuration(int i) {
+        this.thunderTicks = i;
+    }
+
+    public boolean hasStorm() {
+        return this.isRaining;
+    }
+
+    public void setStorm(boolean flag) {
+        this.isRaining = flag;
+    }
+
+    public int getWeatherDuration() {
+        return this.rainTicks;
+    }
+
+    public void setWeatherDuration(int i) {
+        this.rainTicks = i;
+    }
+
+    public EnumGamemode getGameType() {
+        return this.gameType;
+    }
+
+    public boolean shouldGenerateMapFeatures() {
+        return this.useMapFeatures;
+    }
+
+    public void setGameType(EnumGamemode enumgamemode) {
+        this.gameType = enumgamemode;
+    }
+
+    public boolean isHardcore() {
+        return this.hardcore;
+    }
+
+    public WorldType getType() {
+        return this.type;
+    }
+
+    public void setType(WorldType worldtype) {
+        this.type = worldtype;
+    }
+
+    public String getGeneratorOptions() {
+        return this.generatorOptions;
+    }
+
+    public boolean allowCommands() {
+        return this.allowCommands;
+    }
+
+    public boolean isInitialized() {
+        return this.initialized;
+    }
+
+    public void d(boolean flag) {
+        this.initialized = flag;
+    }
+
+    public GameRules getGameRules() {
+        return this.gameRules;
+    }
+
+    public void a(CrashReportSystemDetails crashreportsystemdetails) {
+        crashreportsystemdetails.a("Level seed", (Callable) (new CrashReportLevelSeed(this)));
+        crashreportsystemdetails.a("Level generator", (Callable) (new CrashReportLevelGenerator(this)));
+        crashreportsystemdetails.a("Level generator options", (Callable) (new CrashReportLevelGeneratorOptions(this)));
+        crashreportsystemdetails.a("Level spawn location", (Callable) (new CrashReportLevelSpawnLocation(this)));
+        crashreportsystemdetails.a("Level time", (Callable) (new CrashReportLevelTime(this)));
+        crashreportsystemdetails.a("Level dimension", (Callable) (new CrashReportLevelDimension(this)));
+        crashreportsystemdetails.a("Level storage version", (Callable) (new CrashReportLevelStorageVersion(this)));
+        crashreportsystemdetails.a("Level weather", (Callable) (new CrashReportLevelWeather(this)));
+        crashreportsystemdetails.a("Level game mode", (Callable) (new CrashReportLevelGameMode(this)));
+    }
+
+    static WorldType a(WorldData worlddata) {
+        return worlddata.type;
+    }
+
+    static boolean b(WorldData worlddata) {
+        return worlddata.useMapFeatures;
+    }
+
+    static String c(WorldData worlddata) {
+        return worlddata.generatorOptions;
+    }
+
+    static int d(WorldData worlddata) {
+        return worlddata.spawnX;
+    }
+
+    static int e(WorldData worlddata) {
+        return worlddata.spawnY;
+    }
+
+    static int f(WorldData worlddata) {
+        return worlddata.spawnZ;
+    }
+
+    static long g(WorldData worlddata) {
+        return worlddata.time;
+    }
+
+    static long h(WorldData worlddata) {
+        return worlddata.dayTime;
+    }
+
+    static int i(WorldData worlddata) {
+        return worlddata.dimension;
+    }
+
+    static int j(WorldData worlddata) {
+        return worlddata.version;
+    }
+
+    static int k(WorldData worlddata) {
+        return worlddata.rainTicks;
+    }
+
+    static boolean l(WorldData worlddata) {
+        return worlddata.isRaining;
+    }
+
+    static int m(WorldData worlddata) {
+        return worlddata.thunderTicks;
+    }
+
+    static boolean n(WorldData worlddata) {
+        return worlddata.isThundering;
+    }
+
+    static EnumGamemode o(WorldData worlddata) {
+        return worlddata.gameType;
+    }
+
+    static boolean p(WorldData worlddata) {
+        return worlddata.hardcore;
+    }
+
+    static boolean q(WorldData worlddata) {
+        return worlddata.allowCommands;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenCanyon.java b/src/main/java/net/minecraft/server/WorldGenCanyon.java
new file mode 100644
index 000000000..5c68df1a0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenCanyon.java
@@ -0,0 +1,189 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenCanyon extends WorldGenBase {
+
+    private float[] d = new float[1024];
+
+    public WorldGenCanyon() {}
+
+    protected void a(long i, int j, int k, Block[] ablock, double d0, double d1, double d2, float f, float f1, float f2, int l, int i1, double d3) {
+        Random random = new Random(i);
+        double d4 = (double) (j * 16 + 8);
+        double d5 = (double) (k * 16 + 8);
+        float f3 = 0.0F;
+        float f4 = 0.0F;
+
+        if (i1 <= 0) {
+            int j1 = this.a * 16 - 16;
+
+            i1 = j1 - random.nextInt(j1 / 4);
+        }
+
+        boolean flag = false;
+
+        if (l == -1) {
+            l = i1 / 2;
+            flag = true;
+        }
+
+        float f5 = 1.0F;
+
+        for (int k1 = 0; k1 < 256; ++k1) {
+            if (k1 == 0 || random.nextInt(3) == 0) {
+                f5 = 1.0F + random.nextFloat() * random.nextFloat() * 1.0F;
+            }
+
+            this.d[k1] = f5 * f5;
+        }
+
+        for (; l < i1; ++l) {
+            double d6 = 1.5D + (double) (MathHelper.sin((float) l * 3.1415927F / (float) i1) * f * 1.0F);
+            double d7 = d6 * d3;
+
+            d6 *= (double) random.nextFloat() * 0.25D + 0.75D;
+            d7 *= (double) random.nextFloat() * 0.25D + 0.75D;
+            float f6 = MathHelper.cos(f2);
+            float f7 = MathHelper.sin(f2);
+
+            d0 += (double) (MathHelper.cos(f1) * f6);
+            d1 += (double) f7;
+            d2 += (double) (MathHelper.sin(f1) * f6);
+            f2 *= 0.7F;
+            f2 += f4 * 0.05F;
+            f1 += f3 * 0.05F;
+            f4 *= 0.8F;
+            f3 *= 0.5F;
+            f4 += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 2.0F;
+            f3 += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 4.0F;
+            if (flag || random.nextInt(4) != 0) {
+                double d8 = d0 - d4;
+                double d9 = d2 - d5;
+                double d10 = (double) (i1 - l);
+                double d11 = (double) (f + 2.0F + 16.0F);
+
+                if (d8 * d8 + d9 * d9 - d10 * d10 > d11 * d11) {
+                    return;
+                }
+
+                if (d0 >= d4 - 16.0D - d6 * 2.0D && d2 >= d5 - 16.0D - d6 * 2.0D && d0 <= d4 + 16.0D + d6 * 2.0D && d2 <= d5 + 16.0D + d6 * 2.0D) {
+                    int l1 = MathHelper.floor(d0 - d6) - j * 16 - 1;
+                    int i2 = MathHelper.floor(d0 + d6) - j * 16 + 1;
+                    int j2 = MathHelper.floor(d1 - d7) - 1;
+                    int k2 = MathHelper.floor(d1 + d7) + 1;
+                    int l2 = MathHelper.floor(d2 - d6) - k * 16 - 1;
+                    int i3 = MathHelper.floor(d2 + d6) - k * 16 + 1;
+
+                    if (l1 < 0) {
+                        l1 = 0;
+                    }
+
+                    if (i2 > 16) {
+                        i2 = 16;
+                    }
+
+                    if (j2 < 1) {
+                        j2 = 1;
+                    }
+
+                    if (k2 > 248) {
+                        k2 = 248;
+                    }
+
+                    if (l2 < 0) {
+                        l2 = 0;
+                    }
+
+                    if (i3 > 16) {
+                        i3 = 16;
+                    }
+
+                    boolean flag1 = false;
+
+                    int j3;
+                    int k3;
+
+                    for (j3 = l1; !flag1 && j3 < i2; ++j3) {
+                        for (int l3 = l2; !flag1 && l3 < i3; ++l3) {
+                            for (int i4 = k2 + 1; !flag1 && i4 >= j2 - 1; --i4) {
+                                k3 = (j3 * 16 + l3) * 256 + i4;
+                                if (i4 >= 0 && i4 < 256) {
+                                    Block block = ablock[k3];
+
+                                    if (block == Blocks.WATER || block == Blocks.STATIONARY_WATER) {
+                                        flag1 = true;
+                                    }
+
+                                    if (i4 != j2 - 1 && j3 != l1 && j3 != i2 - 1 && l3 != l2 && l3 != i3 - 1) {
+                                        i4 = j2;
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    if (!flag1) {
+                        for (j3 = l1; j3 < i2; ++j3) {
+                            double d12 = ((double) (j3 + j * 16) + 0.5D - d0) / d6;
+
+                            for (k3 = l2; k3 < i3; ++k3) {
+                                double d13 = ((double) (k3 + k * 16) + 0.5D - d2) / d6;
+                                int j4 = (j3 * 16 + k3) * 256 + k2;
+                                boolean flag2 = false;
+
+                                if (d12 * d12 + d13 * d13 < 1.0D) {
+                                    for (int k4 = k2 - 1; k4 >= j2; --k4) {
+                                        double d14 = ((double) k4 + 0.5D - d1) / d7;
+
+                                        if ((d12 * d12 + d13 * d13) * (double) this.d[k4] + d14 * d14 / 6.0D < 1.0D) {
+                                            Block block1 = ablock[j4];
+
+                                            if (block1 == Blocks.GRASS) {
+                                                flag2 = true;
+                                            }
+
+                                            if (block1 == Blocks.STONE || block1 == Blocks.DIRT || block1 == Blocks.GRASS) {
+                                                if (k4 < 10) {
+                                                    ablock[j4] = Blocks.LAVA;
+                                                } else {
+                                                    ablock[j4] = null;
+                                                    if (flag2 && ablock[j4 - 1] == Blocks.DIRT) {
+                                                        ablock[j4 - 1] = this.c.getBiome(j3 + j * 16, k3 + k * 16).ai;
+                                                    }
+                                                }
+                                            }
+                                        }
+
+                                        --j4;
+                                    }
+                                }
+                            }
+                        }
+
+                        if (flag) {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    protected void a(World world, int i, int j, int k, int l, Block[] ablock) {
+        if (this.b.nextInt(50) == 0) {
+            double d0 = (double) (i * 16 + this.b.nextInt(16));
+            double d1 = (double) (this.b.nextInt(this.b.nextInt(40) + 8) + 20);
+            double d2 = (double) (j * 16 + this.b.nextInt(16));
+            byte b0 = 1;
+
+            for (int i1 = 0; i1 < b0; ++i1) {
+                float f = this.b.nextFloat() * 3.1415927F * 2.0F;
+                float f1 = (this.b.nextFloat() - 0.5F) * 2.0F / 8.0F;
+                float f2 = (this.b.nextFloat() * 2.0F + this.b.nextFloat()) * 2.0F;
+
+                this.a(this.b.nextLong(), k, l, ablock, d0, d1, d2, f2, f, f1, 0, 0, 3.0D);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenCaves.java b/src/main/java/net/minecraft/server/WorldGenCaves.java
new file mode 100644
index 000000000..707938031
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenCaves.java
@@ -0,0 +1,206 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenCaves extends WorldGenBase {
+
+    public WorldGenCaves() {}
+
+    protected void a(long i, int j, int k, Block[] ablock, double d0, double d1, double d2) {
+        this.a(i, j, k, ablock, d0, d1, d2, 1.0F + this.b.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
+    }
+
+    protected void a(long i, int j, int k, Block[] ablock, double d0, double d1, double d2, float f, float f1, float f2, int l, int i1, double d3) {
+        double d4 = (double) (j * 16 + 8);
+        double d5 = (double) (k * 16 + 8);
+        float f3 = 0.0F;
+        float f4 = 0.0F;
+        Random random = new Random(i);
+
+        if (i1 <= 0) {
+            int j1 = this.a * 16 - 16;
+
+            i1 = j1 - random.nextInt(j1 / 4);
+        }
+
+        boolean flag = false;
+
+        if (l == -1) {
+            l = i1 / 2;
+            flag = true;
+        }
+
+        int k1 = random.nextInt(i1 / 2) + i1 / 4;
+
+        for (boolean flag1 = random.nextInt(6) == 0; l < i1; ++l) {
+            double d6 = 1.5D + (double) (MathHelper.sin((float) l * 3.1415927F / (float) i1) * f * 1.0F);
+            double d7 = d6 * d3;
+            float f5 = MathHelper.cos(f2);
+            float f6 = MathHelper.sin(f2);
+
+            d0 += (double) (MathHelper.cos(f1) * f5);
+            d1 += (double) f6;
+            d2 += (double) (MathHelper.sin(f1) * f5);
+            if (flag1) {
+                f2 *= 0.92F;
+            } else {
+                f2 *= 0.7F;
+            }
+
+            f2 += f4 * 0.1F;
+            f1 += f3 * 0.1F;
+            f4 *= 0.9F;
+            f3 *= 0.75F;
+            f4 += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 2.0F;
+            f3 += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 4.0F;
+            if (!flag && l == k1 && f > 1.0F && i1 > 0) {
+                this.a(random.nextLong(), j, k, ablock, d0, d1, d2, random.nextFloat() * 0.5F + 0.5F, f1 - 1.5707964F, f2 / 3.0F, l, i1, 1.0D);
+                this.a(random.nextLong(), j, k, ablock, d0, d1, d2, random.nextFloat() * 0.5F + 0.5F, f1 + 1.5707964F, f2 / 3.0F, l, i1, 1.0D);
+                return;
+            }
+
+            if (flag || random.nextInt(4) != 0) {
+                double d8 = d0 - d4;
+                double d9 = d2 - d5;
+                double d10 = (double) (i1 - l);
+                double d11 = (double) (f + 2.0F + 16.0F);
+
+                if (d8 * d8 + d9 * d9 - d10 * d10 > d11 * d11) {
+                    return;
+                }
+
+                if (d0 >= d4 - 16.0D - d6 * 2.0D && d2 >= d5 - 16.0D - d6 * 2.0D && d0 <= d4 + 16.0D + d6 * 2.0D && d2 <= d5 + 16.0D + d6 * 2.0D) {
+                    int l1 = MathHelper.floor(d0 - d6) - j * 16 - 1;
+                    int i2 = MathHelper.floor(d0 + d6) - j * 16 + 1;
+                    int j2 = MathHelper.floor(d1 - d7) - 1;
+                    int k2 = MathHelper.floor(d1 + d7) + 1;
+                    int l2 = MathHelper.floor(d2 - d6) - k * 16 - 1;
+                    int i3 = MathHelper.floor(d2 + d6) - k * 16 + 1;
+
+                    if (l1 < 0) {
+                        l1 = 0;
+                    }
+
+                    if (i2 > 16) {
+                        i2 = 16;
+                    }
+
+                    if (j2 < 1) {
+                        j2 = 1;
+                    }
+
+                    if (k2 > 248) {
+                        k2 = 248;
+                    }
+
+                    if (l2 < 0) {
+                        l2 = 0;
+                    }
+
+                    if (i3 > 16) {
+                        i3 = 16;
+                    }
+
+                    boolean flag2 = false;
+
+                    int j3;
+                    int k3;
+
+                    for (j3 = l1; !flag2 && j3 < i2; ++j3) {
+                        for (int l3 = l2; !flag2 && l3 < i3; ++l3) {
+                            for (int i4 = k2 + 1; !flag2 && i4 >= j2 - 1; --i4) {
+                                k3 = (j3 * 16 + l3) * 256 + i4;
+                                if (i4 >= 0 && i4 < 256) {
+                                    Block block = ablock[k3];
+
+                                    if (block == Blocks.WATER || block == Blocks.STATIONARY_WATER) {
+                                        flag2 = true;
+                                    }
+
+                                    if (i4 != j2 - 1 && j3 != l1 && j3 != i2 - 1 && l3 != l2 && l3 != i3 - 1) {
+                                        i4 = j2;
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    if (!flag2) {
+                        for (j3 = l1; j3 < i2; ++j3) {
+                            double d12 = ((double) (j3 + j * 16) + 0.5D - d0) / d6;
+
+                            for (k3 = l2; k3 < i3; ++k3) {
+                                double d13 = ((double) (k3 + k * 16) + 0.5D - d2) / d6;
+                                int j4 = (j3 * 16 + k3) * 256 + k2;
+                                boolean flag3 = false;
+
+                                if (d12 * d12 + d13 * d13 < 1.0D) {
+                                    for (int k4 = k2 - 1; k4 >= j2; --k4) {
+                                        double d14 = ((double) k4 + 0.5D - d1) / d7;
+
+                                        if (d14 > -0.7D && d12 * d12 + d14 * d14 + d13 * d13 < 1.0D) {
+                                            Block block1 = ablock[j4];
+
+                                            if (block1 == Blocks.GRASS) {
+                                                flag3 = true;
+                                            }
+
+                                            if (block1 == Blocks.STONE || block1 == Blocks.DIRT || block1 == Blocks.GRASS) {
+                                                if (k4 < 10) {
+                                                    ablock[j4] = Blocks.STATIONARY_LAVA;
+                                                } else {
+                                                    ablock[j4] = null;
+                                                    if (flag3 && ablock[j4 - 1] == Blocks.DIRT) {
+                                                        ablock[j4 - 1] = this.c.getBiome(j3 + j * 16, k3 + k * 16).ai;
+                                                    }
+                                                }
+                                            }
+                                        }
+
+                                        --j4;
+                                    }
+                                }
+                            }
+                        }
+
+                        if (flag) {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    protected void a(World world, int i, int j, int k, int l, Block[] ablock) {
+        int i1 = this.b.nextInt(this.b.nextInt(this.b.nextInt(15) + 1) + 1);
+
+        if (this.b.nextInt(7) != 0) {
+            i1 = 0;
+        }
+
+        for (int j1 = 0; j1 < i1; ++j1) {
+            double d0 = (double) (i * 16 + this.b.nextInt(16));
+            double d1 = (double) this.b.nextInt(this.b.nextInt(120) + 8);
+            double d2 = (double) (j * 16 + this.b.nextInt(16));
+            int k1 = 1;
+
+            if (this.b.nextInt(4) == 0) {
+                this.a(this.b.nextLong(), k, l, ablock, d0, d1, d2);
+                k1 += this.b.nextInt(4);
+            }
+
+            for (int l1 = 0; l1 < k1; ++l1) {
+                float f = this.b.nextFloat() * 3.1415927F * 2.0F;
+                float f1 = (this.b.nextFloat() - 0.5F) * 2.0F / 8.0F;
+                float f2 = this.b.nextFloat() * 2.0F + this.b.nextFloat();
+
+                if (this.b.nextInt(10) == 0) {
+                    f2 *= this.b.nextFloat() * this.b.nextFloat() * 3.0F + 1.0F;
+                }
+
+                this.a(this.b.nextLong(), k, l, ablock, d0, d1, d2, f2, f, f1, 0, 0, 1.0D);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenMinable.java b/src/main/java/net/minecraft/server/WorldGenMinable.java
new file mode 100644
index 000000000..1d58f3e56
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenMinable.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenMinable extends WorldGenerator {
+
+    private Block a;
+    private int b;
+    private Block c;
+
+    public WorldGenMinable(Block block, int i) {
+        this(block, i, Blocks.STONE);
+    }
+
+    public WorldGenMinable(Block block, int i, Block block1) {
+        this.a = block;
+        this.b = i;
+        this.c = block1;
+    }
+
+    public boolean generate(World world, Random random, int i, int j, int k) {
+        float f = random.nextFloat() * 3.1415927F;
+        double d0 = (double) ((float) (i + 8) + MathHelper.sin(f) * (float) this.b / 8.0F);
+        double d1 = (double) ((float) (i + 8) - MathHelper.sin(f) * (float) this.b / 8.0F);
+        double d2 = (double) ((float) (k + 8) + MathHelper.cos(f) * (float) this.b / 8.0F);
+        double d3 = (double) ((float) (k + 8) - MathHelper.cos(f) * (float) this.b / 8.0F);
+        double d4 = (double) (j + random.nextInt(3) - 2);
+        double d5 = (double) (j + random.nextInt(3) - 2);
+
+        for (int l = 0; l <= this.b; ++l) {
+            double d6 = d0 + (d1 - d0) * (double) l / (double) this.b;
+            double d7 = d4 + (d5 - d4) * (double) l / (double) this.b;
+            double d8 = d2 + (d3 - d2) * (double) l / (double) this.b;
+            double d9 = random.nextDouble() * (double) this.b / 16.0D;
+            double d10 = (double) (MathHelper.sin((float) l * 3.1415927F / (float) this.b) + 1.0F) * d9 + 1.0D;
+            double d11 = (double) (MathHelper.sin((float) l * 3.1415927F / (float) this.b) + 1.0F) * d9 + 1.0D;
+            int i1 = MathHelper.floor(d6 - d10 / 2.0D);
+            int j1 = MathHelper.floor(d7 - d11 / 2.0D);
+            int k1 = MathHelper.floor(d8 - d10 / 2.0D);
+            int l1 = MathHelper.floor(d6 + d10 / 2.0D);
+            int i2 = MathHelper.floor(d7 + d11 / 2.0D);
+            int j2 = MathHelper.floor(d8 + d10 / 2.0D);
+
+            for (int k2 = i1; k2 <= l1; ++k2) {
+                double d12 = ((double) k2 + 0.5D - d6) / (d10 / 2.0D);
+
+                if (d12 * d12 < 1.0D) {
+                    for (int l2 = j1; l2 <= i2; ++l2) {
+                        double d13 = ((double) l2 + 0.5D - d7) / (d11 / 2.0D);
+
+                        if (d12 * d12 + d13 * d13 < 1.0D) {
+                            for (int i3 = k1; i3 <= j2; ++i3) {
+                                double d14 = ((double) i3 + 0.5D - d8) / (d10 / 2.0D);
+
+                                if (d12 * d12 + d13 * d13 + d14 * d14 < 1.0D && world.getType(k2, l2, i3) == this.c) {
+                                    world.setTypeAndData(k2, l2, i3, this.a, 0, 2);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldProvider.java b/src/main/java/net/minecraft/server/WorldProvider.java
new file mode 100644
index 000000000..bd9156552
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldProvider.java
@@ -0,0 +1,99 @@
+package net.minecraft.server;
+
+public abstract class WorldProvider {
+
+    public static final float[] a = new float[] { 1.0F, 0.75F, 0.5F, 0.25F, 0.0F, 0.25F, 0.5F, 0.75F};
+    public World b;
+    public WorldType type;
+    public String d;
+    public WorldChunkManager e;
+    public boolean f;
+    public boolean g;
+    public float[] h = new float[16];
+    public int dimension;
+    private float[] j = new float[4];
+
+    public WorldProvider() {}
+
+    public final void a(World world) {
+        this.b = world;
+        this.type = world.getWorldData().getType();
+        this.d = world.getWorldData().getGeneratorOptions();
+        this.b();
+        this.a();
+    }
+
+    protected void a() {
+        float f = 0.0F;
+
+        for (int i = 0; i <= 15; ++i) {
+            float f1 = 1.0F - (float) i / 15.0F;
+
+            this.h[i] = (1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f;
+        }
+    }
+
+    protected void b() {
+        if (this.b.getWorldData().getType() == WorldType.FLAT) {
+            WorldGenFlatInfo worldgenflatinfo = WorldGenFlatInfo.a(this.b.getWorldData().getGeneratorOptions());
+
+            this.e = new WorldChunkManagerHell(BiomeBase.getBiome(worldgenflatinfo.a()), 0.5F);
+        } else {
+            this.e = new WorldChunkManager(this.b);
+        }
+    }
+
+    public IChunkProvider getChunkProvider() {
+        return (IChunkProvider) (this.type == WorldType.FLAT ? new ChunkProviderFlat(this.b, this.b.getSeed(), this.b.getWorldData().shouldGenerateMapFeatures(), this.d) : new ChunkProviderGenerate(this.b, this.b.getSeed(), this.b.getWorldData().shouldGenerateMapFeatures()));
+    }
+
+    public boolean canSpawn(int i, int j) {
+        return this.b.b(i, j) == Blocks.GRASS;
+    }
+
+    public float a(long i, float f) {
+        int j = (int) (i % 24000L);
+        float f1 = ((float) j + f) / 24000.0F - 0.25F;
+
+        if (f1 < 0.0F) {
+            ++f1;
+        }
+
+        if (f1 > 1.0F) {
+            --f1;
+        }
+
+        float f2 = f1;
+
+        f1 = 1.0F - (float) ((Math.cos((double) f1 * 3.141592653589793D) + 1.0D) / 2.0D);
+        f1 = f2 + (f1 - f2) / 3.0F;
+        return f1;
+    }
+
+    public int a(long i) {
+        return (int) (i / 24000L % 8L + 8L) % 8;
+    }
+
+    public boolean d() {
+        return true;
+    }
+
+    public boolean e() {
+        return true;
+    }
+
+    public static WorldProvider byDimension(int i) {
+        return (WorldProvider) (i == -1 ? new WorldProviderHell() : (i == 0 ? new WorldProviderNormal() : (i == 1 ? new WorldProviderTheEnd() : null)));
+    }
+
+    public ChunkCoordinates h() {
+        return null;
+    }
+
+    public int getSeaLevel() {
+        return this.type == WorldType.FLAT ? 4 : 64;
+    }
+
+    public abstract String getName();
+
+}
-- 
2.15.2 (Apple Git-101.1)

